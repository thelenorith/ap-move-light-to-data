"""
Move light frames to data directory when calibration frames are available.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import argparse
import logging
import os
import shutil
from pathlib import Path
from typing import List

import ap_common
from ap_common import setup_logging, progress_iter
from ap_common.constants import (
    TYPE_LIGHT,
    NORMALIZED_HEADER_DATE,
    NORMALIZED_HEADER_FILTER,
)

from . import config
from .matching import check_calibration_status

logger = logging.getLogger("ap_move_light_to_data.move_lights_to_data")


def find_light_directories(
    source_dir: str,
    debug: bool = False,
) -> List[str]:
    """
    Find directories containing light frames in the source directory.

    Uses ap-common metadata filtering to identify LIGHT frames specifically,
    not just any image files. Returns unique directories containing lights.

    Args:
        source_dir: Root directory to search (e.g., 10_Blink)
        debug: Enable debug output

    Returns:
        List of directory paths containing light frames
    """
    source_path = Path(ap_common.replace_env_vars(source_dir))

    logger.debug(f"Searching for light directories in: {source_path}")

    # Use ap-common to find LIGHT frames specifically
    light_metadata = ap_common.get_filtered_metadata(
        dirs=[str(source_path)],
        patterns=config.SUPPORTED_EXTENSIONS,
        recursive=True,
        required_properties=[config.NORMALIZED_HEADER_TYPE],
        filters={config.NORMALIZED_HEADER_TYPE: TYPE_LIGHT},
        profileFromPath=True,
        debug=debug,
        printStatus=debug,
    )

    # Extract unique directories from light frame paths
    light_dirs = set()
    for filepath in light_metadata.keys():
        directory = os.path.dirname(filepath)
        if directory not in light_dirs:
            light_dirs.add(directory)
            logger.debug(f"Found light frame in: {directory}")

    result = sorted(light_dirs)
    logger.debug(f"Found {len(result)} directories with light frames")

    return result


def get_target_from_path(light_dir: str, source_dir: str) -> str:
    """
    Extract the target/structure path relative to source directory.

    Args:
        light_dir: Full path to light directory
        source_dir: Source root directory (e.g., 10_Blink path)

    Returns:
        Relative path structure (e.g., "M31/DATE_2024-01-15/...")
    """
    source_path = Path(ap_common.replace_env_vars(source_dir))
    light_path = Path(light_dir)

    try:
        relative = light_path.relative_to(source_path)
        return str(relative)
    except ValueError:
        # Fallback to just the directory name
        logger.warning(
            f"Could not compute relative path from {source_path} to {light_path}, "
            f"using directory name"
        )
        return light_path.name


def move_directory(
    source: str,
    dest: str,
    dry_run: bool = False,
) -> bool:
    """
    Move a directory and its contents to a new location.

    Args:
        source: Source directory path
        dest: Destination directory path
        dry_run: If True, only print what would be done

    Returns:
        True if successful (or dry run), False otherwise
    """
    source_path = Path(source)
    dest_path = Path(dest)

    logger.debug(f"Moving: {source_path} -> {dest_path}")

    if dry_run:
        return True

    try:
        # Create parent directory if needed
        dest_path.parent.mkdir(parents=True, exist_ok=True)
        logger.debug(f"Created parent directory: {dest_path.parent}")

        # Move the directory
        shutil.move(str(source_path), str(dest_path))
        logger.debug(f"Successfully moved: {source_path} -> {dest_path}")
        return True
    except (OSError, shutil.Error) as e:
        logger.error(f"Error moving directory from {source_path} to {dest_path}: {e}")
        return False


def move_target_files(
    lights_dir: str,
    source_dir: str,
    dest_dir: str,
    dry_run: bool = False,
) -> int:
    """
    Move non-FITS files from target-level directory when lights dir is a leaf.

    If the lights directory has no subdirectories (is a leaf), this moves all
    non-directory files from the target-level directory (first directory under
    source_dir) to the corresponding location in dest_dir.

    Args:
        lights_dir: Directory containing light frames
        source_dir: Source root directory
        dest_dir: Destination root directory
        dry_run: If True, only print what would be done

    Returns:
        Number of files successfully moved
    """
    lights_path = Path(lights_dir)
    source_path = Path(ap_common.replace_env_vars(source_dir))
    dest_path = Path(ap_common.replace_env_vars(dest_dir))

    # Check if lights directory is a leaf (has no subdirectories)
    has_subdirs = any(lights_path.iterdir()) and any(
        item.is_dir() for item in lights_path.iterdir()
    )
    if has_subdirs:
        logger.debug(
            f"Lights directory {lights_dir} has subdirectories, skipping target files"
        )
        return 0

    # Find target-level directory (first directory under source_dir)
    try:
        relative_to_source = lights_path.relative_to(source_path)
        parts = relative_to_source.parts
        if not parts:
            logger.debug("Lights directory is source directory, no target level")
            return 0

        target_dir = source_path / parts[0]
    except ValueError:
        logger.warning(
            f"Lights directory {lights_dir} is not under source {source_path}"
        )
        return 0

    # Find all non-directory files in target directory
    moved_count = 0
    try:
        for item in target_dir.iterdir():
            if item.is_file():
                # Calculate destination path
                dest_target = dest_path / parts[0]
                dest_file = dest_target / item.name

                # Move the file
                try:
                    ap_common.move_file(str(item), str(dest_file), dryrun=dry_run)
                    moved_count += 1
                    logger.debug(f"Moved target file: {item} -> {dest_file}")
                except Exception as e:
                    logger.error(f"Failed to move target file {item}: {e}")
    except Exception as e:
        logger.error(f"Error iterating target directory {target_dir}: {e}")

    return moved_count


def move_calibration_files(
    calibration_files: List[str],
    source_dir: str,
    dest_dir: str,
    dry_run: bool = False,
) -> int:
    """
    Move calibration files while preserving directory structure.

    Args:
        calibration_files: List of calibration file paths to move
        source_dir: Source root directory
        dest_dir: Destination root directory
        dry_run: If True, only print what would be done

    Returns:
        Number of files successfully moved
    """
    source_path = Path(ap_common.replace_env_vars(source_dir))
    dest_path = Path(ap_common.replace_env_vars(dest_dir))
    moved_count = 0

    for cal_file in calibration_files:
        cal_path = Path(cal_file)

        try:
            # Calculate relative path from source directory
            relative_path = cal_path.relative_to(source_path)
        except ValueError:
            # File is not under source_dir, skip it
            logger.warning(
                f"Calibration file {cal_file} is not under source directory {source_path}, skipping"
            )
            continue

        # Calculate destination path
        dest_file = dest_path / relative_path

        # Move the file using ap-common's move_file
        try:
            ap_common.move_file(str(cal_path), str(dest_file), dryrun=dry_run)
            moved_count += 1
            logger.debug(f"Moved calibration file: {cal_file} -> {dest_file}")
        except OSError as e:
            logger.error(f"Failed to move calibration file {cal_file}: {e}")

    return moved_count


def process_light_directories(
    source_dir: str,
    dest_dir: str,
    debug: bool = False,
    dry_run: bool = False,
    quiet: bool = False,
    allow_bias: bool = False,
) -> dict:
    """
    Process light directories and move those with calibration frames.

    Calibration frames (darks, flats, and bias if needed) are searched for
    in the lights directory first, then in parent directories up to (but not
    including) the source directory.

    Args:
        source_dir: Source directory containing lights (e.g., 10_Blink)
        dest_dir: Destination directory (e.g., 20_Data)
        debug: Enable debug output
        dry_run: If True, only print what would be done
        quiet: If True, suppress progress output

    Returns:
        Dict with counts: moved, skipped (by reason), errors
    """
    results = {
        "dir_count": 0,
        "target_count": 0,
        "date_count": 0,
        "filter_count": 0,
        "moved": 0,
        "skipped_no_lights": 0,
        "skipped_no_darks": 0,
        "skipped_no_flats": 0,
        "skipped_no_bias": 0,
        "errors": 0,
    }

    source_path = Path(ap_common.replace_env_vars(source_dir))
    dest_path = Path(ap_common.replace_env_vars(dest_dir))

    logger.debug(f"Processing light directories from {source_path} to {dest_path}")

    # Find all directories with image files
    image_dirs = find_light_directories(source_dir, debug)

    if not image_dirs:
        logger.warning(f"No light frame directories found in {source_path}")
        return results

    logger.debug(f"Found {len(image_dirs)} directories to check")

    # Extract organizational metrics from light frames
    targets = set()
    dates = set()
    filters = set()

    for image_dir in image_dirs:
        status = check_calibration_status(image_dir, source_dir, allow_bias=allow_bias)
        # Extract target from path (source/TARGET/DATE/FILTER_EXP_SETTEMP/)
        try:
            rel_path = Path(image_dir).relative_to(source_path)
            if len(rel_path.parts) > 0:
                targets.add(rel_path.parts[0])
        except (ValueError, IndexError):
            pass

        # Extract date and filter from representative light frame metadata
        light_metadata = status.get("light_metadata")
        if light_metadata:
            if NORMALIZED_HEADER_DATE in light_metadata:
                dates.add(light_metadata[NORMALIZED_HEADER_DATE])
            if NORMALIZED_HEADER_FILTER in light_metadata:
                filters.add(light_metadata[NORMALIZED_HEADER_FILTER])

    results["dir_count"] = len(image_dirs)
    results["target_count"] = len(targets)
    results["date_count"] = len(dates)
    results["filter_count"] = len(filters)

    # Collect warnings to print after progress bar
    warnings = []

    for image_dir in progress_iter(
        image_dirs, desc="Processing directories", enabled=not quiet
    ):
        relative_path = get_target_from_path(image_dir, source_dir)
        logger.debug(f"Processing: {relative_path}")

        # Check calibration status
        status = check_calibration_status(image_dir, source_dir, debug, allow_bias)
        logger.debug(
            f"Calibration status for {relative_path}: "
            f"lights={status['light_count']}, darks={status['dark_count']}, "
            f"flats={status['flat_count']}, bias={status['bias_count']}, "
            f"complete={status['is_complete']}"
        )

        if not status["has_lights"]:
            logger.info(f"Skipping {relative_path}: No light frames found")
            results["skipped_no_lights"] += 1
            continue

        logger.debug(
            f"Lights: {status['light_count']}, "
            f"Darks: {status['dark_count']}, "
            f"Flats: {status['flat_count']}, "
            f"Bias: {status['bias_count']}"
        )
        if status["needs_bias"]:
            logger.debug("Note: Bias required (dark exposure != light exposure)")

        if not status["is_complete"]:
            # Use the missing list from calibration status instead of rebuilding
            missing = status.get("missing", [])
            missing_str = ", ".join(missing)
            warnings.append(f"Skipping {relative_path}: missing {missing_str}")

            # Track specific skip reason using structured code
            skip_code = status.get("skip_reason_code", "")
            if skip_code == config.SKIP_REASON_NO_BIAS:
                results["skipped_no_bias"] += 1
            elif skip_code == config.SKIP_REASON_NO_FLATS:
                results["skipped_no_flats"] += 1
            elif skip_code == config.SKIP_REASON_NO_DARKS:
                results["skipped_no_darks"] += 1
            continue

        logger.debug(
            f"  Calibration complete: {status['dark_count']} darks, "
            f"{status['flat_count']} flats"
            + (f", {status['bias_count']} bias" if status["needs_bias"] else "")
        )

        # Move calibration files first (so they're in place before lights)
        total_cal_moved = 0
        total_cal_moved += move_calibration_files(
            status["matched_darks"], source_dir, dest_dir, dry_run
        )
        total_cal_moved += move_calibration_files(
            status["matched_flats"], source_dir, dest_dir, dry_run
        )
        if status["needs_bias"]:
            total_cal_moved += move_calibration_files(
                status["matched_bias"], source_dir, dest_dir, dry_run
            )

        logger.debug(f"Moved {total_cal_moved} calibration files")

        # Move target-level files if lights dir is a leaf (before moving lights)
        target_files_moved = move_target_files(image_dir, source_dir, dest_dir, dry_run)
        if target_files_moved > 0:
            logger.debug(f"Moved {target_files_moved} target-level files")

        # Move the lights directory
        dest_full = dest_path / relative_path
        success = move_directory(image_dir, str(dest_full), dry_run)

        if success:
            results["moved"] += 1
            logger.debug(f"Moved {relative_path} to {dest_full}")
        else:
            results["errors"] += 1
            logger.error(f"Failed to move {relative_path}")

    # Print collected warnings after progress bar completes
    for warning in warnings:
        logger.warning(warning)

    # Cleanup empty directories in source
    if not dry_run and results["moved"] > 0:
        logger.debug(f"Cleaning up empty directories in {source_path}")
        ap_common.delete_empty_directories(str(source_path), dryrun=dry_run)

    logger.debug(
        f"Processing complete: moved={results['moved']}, "
        f"skipped={results['skipped_no_lights'] + results['skipped_no_darks'] + results['skipped_no_flats'] + results['skipped_no_bias']}, "
        f"errors={results['errors']}"
    )
    return results


def print_summary(results: dict) -> None:
    """
    Print summary of processing results.

    Args:
        results: Results dictionary from process_light_directories
    """

    def plural(count: int, singular: str) -> str:
        """Format count with singular/plural form."""
        return f"{count} {singular}{'s' if count != 1 else ''}"

    def status_indicator(present: int, needed: int) -> str:
        """Return status indicator based on present vs needed."""
        return "ok" if present >= needed else "MISSING!"

    print(f"\n{'='*70}")
    print("Summary")
    print(f"{'='*70}")

    # Calculate totals
    dir_count = results["dir_count"]

    print(
        f"Directories: {dir_count} "
        f"({plural(results['target_count'], 'target')}, "
        f"{plural(results['date_count'], 'date')}, "
        f"{plural(results['filter_count'], 'filter')})"
    )
    print(
        f"Darks:  {dir_count - results['skipped_no_darks']} of {dir_count} | "
        f"{status_indicator(dir_count - results['skipped_no_darks'], dir_count)}"
    )
    print(
        f"Flats:  {dir_count - results['skipped_no_flats']} of {dir_count} | "
        f"{status_indicator(dir_count - results['skipped_no_flats'], dir_count)}"
    )
    if results["skipped_no_bias"] > 0:
        print(
            f"Biases: {dir_count - results['skipped_no_bias']} of {dir_count} | "
            f"{status_indicator(dir_count - results['skipped_no_bias'], dir_count)}"
        )
    if results["errors"] > 0:
        print(f"Errors: {results['errors']}")
    print(f"{'='*70}\n")


def main() -> int:
    """Main entry point for CLI.

    Returns:
        0 on success, 1 on processing errors, 2 on usage/validation errors
    """
    parser = argparse.ArgumentParser(
        description="Move light frames to data directory when calibration frames exist. "
        "Calibration frames (darks, flats, bias) are searched for in the lights "
        "directory first, then in parent directories within the source tree."
    )

    parser.add_argument(
        "source_dir",
        help=f"Source directory containing lights (default name: {config.DEFAULT_BLINK_DIR})",
    )

    parser.add_argument(
        "dest_dir",
        help=f"Destination directory for lights (default name: {config.DEFAULT_DATA_DIR})",
    )

    parser.add_argument(
        "--debug",
        "-d",
        action="store_true",
        help="Enable debug output",
    )

    parser.add_argument(
        "--dryrun",
        "-n",
        action="store_true",
        help="Show what would be done without actually moving files",
    )

    parser.add_argument(
        "--quiet",
        "-q",
        action="store_true",
        help="Suppress progress output",
    )

    parser.add_argument(
        "--allow-bias",
        action="store_true",
        help="Allow shorter darks with bias frames. "
        "Default: only exact exposure match darks are accepted.",
    )

    args = parser.parse_args()

    # Setup logging
    logger = setup_logging(
        name="ap_move_light_to_data", debug=args.debug, quiet=args.quiet
    )

    # Validate source directory
    source_path = Path(ap_common.replace_env_vars(args.source_dir))
    if not source_path.exists():
        logger.error(f"Source directory does not exist: {source_path}")
        print(f"ERROR: Source directory does not exist: {source_path}")
        return 2
    if not source_path.is_dir():
        logger.error(f"Source path is not a directory: {source_path}")
        print(f"ERROR: Source path is not a directory: {source_path}")
        return 2
    if not os.access(source_path, os.R_OK):
        logger.error(f"Source directory is not readable: {source_path}")
        print(f"ERROR: Source directory is not readable: {source_path}")
        return 2

    # Validate destination directory parent (dest may not exist yet)
    dest_path = Path(ap_common.replace_env_vars(args.dest_dir))
    # Check if dest exists - if so, must be directory and writable
    if dest_path.exists():
        if not dest_path.is_dir():
            logger.error(f"Destination path exists but is not a directory: {dest_path}")
            print(f"ERROR: Destination path exists but is not a directory: {dest_path}")
            return 2
        if not os.access(dest_path, os.W_OK):
            logger.error(f"Destination directory is not writable: {dest_path}")
            print(f"ERROR: Destination directory is not writable: {dest_path}")
            return 2
    else:
        # Dest doesn't exist - check parent is writable
        if dest_path.parent.exists():
            if not os.access(dest_path.parent, os.W_OK):
                logger.error(
                    f"Cannot create destination directory (parent not writable): {dest_path.parent}"
                )
                print(
                    f"ERROR: Cannot create destination directory (parent not writable): {dest_path.parent}"
                )
                return 2

    print(f"Source directory: {args.source_dir}")
    print(f"Destination directory: {args.dest_dir}")

    if args.dryrun:
        print("\n*** DRY RUN - No files will be moved ***\n")

    results = process_light_directories(
        args.source_dir,
        args.dest_dir,
        args.debug,
        args.dryrun,
        args.quiet,
        args.allow_bias,
    )

    # Print summary
    if not args.quiet:
        print_summary(results)

    # Return 1 if there were any errors during processing
    return 1 if results["errors"] > 0 else 0


if __name__ == "__main__":
    import sys

    sys.exit(main())
