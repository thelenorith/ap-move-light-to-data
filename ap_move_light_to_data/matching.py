"""
Calibration matching using ap-common's calibration module.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import logging
from pathlib import Path
from typing import Dict, List, Any
from ap_common.constants import TYPE_LIGHT, NORMALIZED_HEADER_FILENAME
from ap_common.calibration import (
    find_matching_darks_from_cache,
    find_matching_flats_from_cache,
    find_matching_bias_from_cache,
)

from . import config

logger = logging.getLogger("ap_move_light_to_data.matching")


def get_light_frames(
    directory: str,
    metadata_cache: Dict[str, Dict[str, Any]],
    debug: bool = False,
) -> Dict[str, Dict[str, Any]]:
    """
    Get light frames from a directory (non-recursive).

    Args:
        directory: Directory to scan
        metadata_cache: Pre-loaded metadata dict to filter from
        debug: Enable debug output

    Returns:
        Dict mapping filepath to metadata for light frames only
    """
    # Filter from cache: find files in this directory
    results = {}
    dir_path = Path(directory).resolve()
    for filename, metadata in metadata_cache.items():
        file_path = Path(filename).resolve()
        # Check if file is directly in this directory (not recursive)
        if (
            file_path.parent == dir_path
            and metadata.get(config.NORMALIZED_HEADER_TYPE) == TYPE_LIGHT
        ):
            results[filename] = metadata
    logger.debug(f"Found {len(results)} light frames in cache for {directory}")
    return results


def find_all_light_directories(
    root_dir: str,
    metadata_cache: Dict[str, Dict[str, Any]],
    debug: bool = False,
) -> List[str]:
    """
    Find all directories containing light frames recursively.

    Args:
        root_dir: Root directory to search
        metadata_cache: Pre-loaded metadata dict to extract from
        debug: Enable debug output

    Returns:
        List of directory paths containing light frames
    """
    # Extract unique directories containing lights from cache
    light_dirs = set()
    root_path = Path(root_dir).resolve()
    for filename, metadata in metadata_cache.items():
        if metadata.get(config.NORMALIZED_HEADER_TYPE) == TYPE_LIGHT:
            file_path = Path(filename).resolve()
            # Check if file is under root_dir
            try:
                file_path.relative_to(root_path)
                light_dirs.add(str(file_path.parent))
            except ValueError:
                continue  # File not under root_dir

    result = sorted(light_dirs)
    logger.debug(f"Found {len(result)} light directories in cache")
    return result


def check_calibration_for_light(
    light_metadata: Dict[str, Any],
    search_dirs: List[str],
    metadata_cache: Dict[str, Dict[str, Any]],
    allow_bias: bool,
    debug: bool,
    quiet: bool,
) -> Dict[str, Any]:
    """
    Check if a light frame has required calibration in search directories.

    Args:
        light_metadata: Light frame metadata dict
        search_dirs: Directories to search for calibration (ordered by priority)
        metadata_cache: Pre-loaded metadata dict to search from
        allow_bias: Allow shorter darks with bias frames
        debug: Enable debug output
        quiet: Suppress progress output

    Returns:
        Dict with:
            - has_darks: bool
            - has_flats: bool
            - has_bias: bool (only checked if needs_bias)
            - needs_bias: bool
            - is_complete: bool
            - matched_darks: List[str] (file paths)
            - matched_flats: List[str] (file paths)
            - matched_bias: List[str] (file paths)
            - missing: List[str] (names of missing types)
    """
    result: Dict[str, Any] = {
        "has_darks": False,
        "has_flats": False,
        "has_bias": False,
        "needs_bias": False,
        "is_complete": False,
        "matched_darks": [],
        "matched_flats": [],
        "matched_bias": [],
        "missing": [],
    }

    # Filter cache to search_dirs
    calibration_metadata = {}
    search_paths = [Path(d).resolve() for d in search_dirs]
    for filename, metadata in metadata_cache.items():
        file_path = Path(filename).resolve()
        # Check if file is under any search directory
        for search_path in search_paths:
            try:
                file_path.relative_to(search_path)
                calibration_metadata[filename] = metadata
                break
            except ValueError:
                continue
    logger.debug(f"Filtered {len(calibration_metadata)} calibration files from cache")

    # Search for darks in search directories (stop at first match)
    for search_dir in search_dirs:
        # Filter cache to this search_dir (non-recursive: parent == search_path)
        dir_cache = {
            f: m
            for f, m in calibration_metadata.items()
            if Path(f).resolve().parent == Path(search_dir).resolve()
        }

        darks = (
            find_matching_darks_from_cache(
                metadata_dict=dir_cache,
                reference=light_metadata,
                match_fields=config.DARK_MATCH_KEYWORDS,
                allow_shorter_exposure=allow_bias,
            )
            if dir_cache
            else []
        )

        if darks:
            result["matched_darks"] = [d[NORMALIZED_HEADER_FILENAME] for d in darks]
            result["has_darks"] = True

            # Check if exact exposure match exists
            light_exp = float(
                light_metadata.get(config.NORMALIZED_HEADER_EXPOSURESECONDS, -1)
            )
            exact_match = any(
                float(d.get(config.NORMALIZED_HEADER_EXPOSURESECONDS, -1)) == light_exp
                for d in darks
            )
            result["needs_bias"] = allow_bias and not exact_match
            break

    # Search for flats
    for search_dir in search_dirs:
        # Filter cache to this search_dir (non-recursive: parent == search_path)
        dir_cache = {
            f: m
            for f, m in calibration_metadata.items()
            if Path(f).resolve().parent == Path(search_dir).resolve()
        }

        flats = (
            find_matching_flats_from_cache(
                metadata_dict=dir_cache,
                reference=light_metadata,
                match_fields=config.FLAT_MATCH_KEYWORDS,
            )
            if dir_cache
            else []
        )

        if flats:
            result["matched_flats"] = [f[NORMALIZED_HEADER_FILENAME] for f in flats]
            result["has_flats"] = True
            break

    # Search for bias if needed
    if result["needs_bias"]:
        for search_dir in search_dirs:
            # Filter cache to this search_dir (non-recursive: parent == search_path)
            dir_cache = {
                f: m
                for f, m in calibration_metadata.items()
                if Path(f).resolve().parent == Path(search_dir).resolve()
            }

            bias = (
                find_matching_bias_from_cache(
                    metadata_dict=dir_cache,
                    reference=light_metadata,
                    match_fields=config.DARK_MATCH_KEYWORDS,
                )
                if dir_cache
                else []
            )

            if bias:
                result["matched_bias"] = [b[NORMALIZED_HEADER_FILENAME] for b in bias]
                result["has_bias"] = True
                break

    # Determine completeness
    missing: List[str] = result["missing"]  # type: ignore[assignment]
    if not result["has_darks"]:
        missing.append("darks")
    if not result["has_flats"]:
        missing.append("flats")
    if result["needs_bias"] and not result["has_bias"]:
        missing.append("bias")

    result["is_complete"] = len(missing) == 0

    return result


def is_file_inside_tree(filepath: str, tree_path: str) -> bool:
    """
    Check if a file is inside a directory tree.

    Args:
        filepath: Path to file
        tree_path: Root directory of tree

    Returns:
        True if file is inside tree, False otherwise
    """
    try:
        Path(filepath).resolve().relative_to(Path(tree_path).resolve())
        return True
    except ValueError:
        return False
