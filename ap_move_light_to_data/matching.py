"""
Calibration frame matching logic.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import logging
from pathlib import Path
from typing import Dict, List, Any, Tuple
import ap_common
from ap_common.constants import TYPE_LIGHT, TYPE_DARK, TYPE_FLAT, TYPE_BIAS

from . import config

logger = logging.getLogger("ap_move_light_to_data.matching")


def get_frames_by_type(
    directory: str,
    debug: bool = False,
) -> Dict[str, Dict[str, Any]]:
    """
    Get all frames from a directory grouped by type category.

    Groups frames into lights, darks, flats, and bias, handling MASTER types
    (e.g., "master dark", "MASTER FLAT") by checking if the type string contains
    the frame type name.

    Args:
        directory: Directory to scan for frames
        debug: Enable debug output

    Returns:
        Dict with keys 'lights', 'darks', 'flats', 'bias' containing frame metadata dicts
    """
    logger.debug(f"Scanning directory for frames: {directory}")

    # Get metadata from all files in the directory
    all_metadata = ap_common.get_metadata(
        dirs=[directory],
        patterns=config.SUPPORTED_EXTENSIONS,
        recursive=False,  # explicitly set to False
        required_properties=[config.NORMALIZED_HEADER_TYPE],
        profileFromPath=True,
        printStatus=debug,
    )

    # Group by type category (handles MASTER types like "master dark", "master flat")
    lights = {}
    darks = {}
    flats = {}
    bias = {}

    for filepath, metadata in all_metadata.items():
        frame_type = str(metadata.get(config.NORMALIZED_HEADER_TYPE, "")).lower()

        if TYPE_LIGHT.lower() in frame_type:
            lights[filepath] = metadata
        elif TYPE_DARK.lower() in frame_type:
            darks[filepath] = metadata
        elif TYPE_FLAT.lower() in frame_type:
            flats[filepath] = metadata
        elif TYPE_BIAS.lower() in frame_type:
            bias[filepath] = metadata

    logger.debug(f"Found {len(lights)} light frames")
    logger.debug(f"Found {len(darks)} dark frames")
    logger.debug(f"Found {len(flats)} flat frames")
    logger.debug(f"Found {len(bias)} bias frames")

    return {
        "lights": lights,
        "darks": darks,
        "flats": flats,
        "bias": bias,
    }


def collect_calibration_frames(
    lights_dir: str,
    source_dir: str,
    debug: bool = False,
) -> Dict[str, Dict[str, Any]]:
    """
    Collect calibration frames from lights directory and parent directories.

    Searches lights directory and all parent directories up to (but not including)
    the source directory. This supports mixed scenarios where some calibration
    frames are in the lights directory (e.g., filter-specific flats) and others
    are in parent directories (e.g., shared darks).

    Args:
        lights_dir: Directory containing light frames
        source_dir: Source root directory (stopping point)
        debug: Enable debug output

    Returns:
        Dict with keys 'darks', 'flats', 'bias' containing merged calibration frames
    """
    all_darks = {}
    all_flats = {}
    all_bias = {}

    current_dir = Path(lights_dir).resolve()
    source_path = Path(ap_common.replace_env_vars(source_dir)).resolve()
    checked_dirs = []

    while True:
        logger.debug(f"Checking for calibration frames in: {current_dir}")
        checked_dirs.append(str(current_dir))

        # Get frames from this directory (non-recursive)
        frames = get_frames_by_type(str(current_dir), debug)

        # Merge calibration frames
        all_darks.update(frames["darks"])
        all_flats.update(frames["flats"])
        all_bias.update(frames["bias"])

        # Move to parent
        parent = current_dir.parent
        if parent == current_dir:
            # Reached filesystem root
            logger.debug("Reached filesystem root")
            break

        # Stop if parent is the source directory (don't search source_dir itself)
        if parent == source_path:
            logger.debug(f"Reached source directory boundary: {source_path}")
            break

        current_dir = parent

    logger.debug(
        f"Collected {len(all_darks)} darks, {len(all_flats)} flats, "
        f"{len(all_bias)} bias from: {', '.join(checked_dirs)}"
    )

    return {
        "darks": all_darks,
        "flats": all_flats,
        "bias": all_bias,
    }


def find_matching_darks(
    light_metadata: Dict[str, Any],
    dark_frames: Dict[str, Dict[str, Any]],
) -> Tuple[List[str], bool]:
    """
    Find dark frames that match the light frame settings.

    Args:
        light_metadata: Metadata dict for a light frame
        dark_frames: Dict of dark frame metadata keyed by filepath

    Returns:
        Tuple of (list of matching dark file paths, exposure_matches)
        exposure_matches is True if any dark has same exposure as light
    """
    matching = []
    exposure_matches = False
    light_exposure = light_metadata.get(config.NORMALIZED_HEADER_EXPOSURESECONDS)
    logger.debug(f"Matching darks for light with exposure={light_exposure}s")

    for filepath, dark_meta in dark_frames.items():
        # Check all match keywords
        matches = True
        for key in config.DARK_MATCH_KEYWORDS:
            light_val = light_metadata.get(key)
            dark_val = dark_meta.get(key)
            if light_val is not None and dark_val is not None:
                if str(light_val).lower() != str(dark_val).lower():
                    matches = False
                    break

        if matches:
            matching.append(filepath)
            # Check if exposure matches
            dark_exposure = dark_meta.get(config.NORMALIZED_HEADER_EXPOSURESECONDS)
            if light_exposure is not None and dark_exposure is not None:
                try:
                    if float(light_exposure) == float(dark_exposure):
                        exposure_matches = True
                        logger.debug(
                            f"Exposure match: light={light_exposure}s, dark={dark_exposure}s "
                            f"(file: {filepath})"
                        )
                    else:
                        logger.debug(
                            f"Exposure mismatch: light={light_exposure}s, dark={dark_exposure}s "
                            f"(file: {filepath})"
                        )
                except (ValueError, TypeError):
                    pass

    logger.debug(
        f"Found {len(matching)} matching darks, exposure_matches={exposure_matches}"
    )

    return matching, exposure_matches


def find_matching_flats(
    light_metadata: Dict[str, Any],
    flat_frames: Dict[str, Dict[str, Any]],
) -> List[str]:
    """
    Find flat frames that match the light frame settings.

    Args:
        light_metadata: Metadata dict for a light frame
        flat_frames: Dict of flat frame metadata keyed by filepath

    Returns:
        List of matching flat file paths
    """
    matching = []

    for filepath, flat_meta in flat_frames.items():
        # Check all match keywords
        matches = True
        for key in config.FLAT_MATCH_KEYWORDS:
            light_val = light_metadata.get(key)
            flat_val = flat_meta.get(key)
            if light_val is not None and flat_val is not None:
                if str(light_val).lower() != str(flat_val).lower():
                    matches = False
                    break

        if matches:
            matching.append(filepath)

    logger.debug(f"Found {len(matching)} matching flats")

    return matching


def find_matching_bias(
    light_metadata: Dict[str, Any],
    bias_frames: Dict[str, Dict[str, Any]],
) -> List[str]:
    """
    Find bias frames that match the light frame settings.

    Args:
        light_metadata: Metadata dict for a light frame
        bias_frames: Dict of bias frame metadata keyed by filepath

    Returns:
        List of matching bias file paths
    """
    matching = []

    # Bias matches on same keywords as dark (minus exposure)
    for filepath, bias_meta in bias_frames.items():
        matches = True
        for key in config.DARK_MATCH_KEYWORDS:
            light_val = light_metadata.get(key)
            bias_val = bias_meta.get(key)
            if light_val is not None and bias_val is not None:
                if str(light_val).lower() != str(bias_val).lower():
                    matches = False
                    break

        if matches:
            matching.append(filepath)

    logger.debug(f"Found {len(matching)} matching bias frames")

    return matching


def check_calibration_status(
    directory: str,
    source_dir: str,
    debug: bool = False,
) -> Dict[str, Any]:
    """
    Check calibration status for a directory containing lights.

    Calibration frames are searched for in the lights directory first, then
    in parent directories up to (but not including) the source directory.
    Bias is only required if dark exposure doesn't match light exposure.

    Args:
        directory: Directory containing light frames and calibration
        source_dir: Source root directory (boundary for parent search)
        debug: Enable debug output

    Returns:
        Dict with:
            - has_lights: bool
            - has_darks: bool
            - has_flats: bool
            - has_bias: bool
            - needs_bias: bool (True if dark exposure != light exposure)
            - is_complete: bool (has all required calibration)
            - light_count, dark_count, flat_count, bias_count: int
            - light_metadata: representative light metadata
            - reason: str explaining why incomplete (if applicable)
            - matched_darks: list of dark file paths that match the lights
            - matched_flats: list of flat file paths that match the lights
            - matched_bias: list of bias file paths that match the lights
    """
    result: Dict[str, Any] = {
        "has_lights": False,
        "has_darks": False,
        "has_flats": False,
        "has_bias": False,
        "needs_bias": False,
        "is_complete": False,
        "light_count": 0,
        "dark_count": 0,
        "flat_count": 0,
        "bias_count": 0,
        "light_metadata": None,
        "reason": "",
        "skip_reason_code": config.SKIP_REASON_NONE,
        "missing": [],
        "matched_darks": [],
        "matched_flats": [],
        "matched_bias": [],
    }

    # Get light frames from the specified directory
    light_frames = get_frames_by_type(directory, debug)
    lights = light_frames["lights"]

    # Collect calibration frames from lights directory and parents
    # This supports mixed scenarios (e.g., flats in lights dir, darks in parent)
    calibration_frames = collect_calibration_frames(directory, source_dir, debug)
    darks = calibration_frames["darks"]
    flats = calibration_frames["flats"]
    bias = calibration_frames["bias"]

    result["light_count"] = len(lights)
    result["has_lights"] = len(lights) > 0

    if not lights:
        result["reason"] = "No light frames found"
        result["skip_reason_code"] = config.SKIP_REASON_NO_LIGHTS
        return result

    # Get representative light metadata
    light_metadata = next(iter(lights.values()))
    result["light_metadata"] = light_metadata

    # Find matching darks
    matching_darks, exposure_matches = find_matching_darks(light_metadata, darks)
    result["dark_count"] = len(matching_darks)
    result["has_darks"] = len(matching_darks) > 0
    result["matched_darks"] = matching_darks

    # Determine if bias is needed
    result["needs_bias"] = not exposure_matches
    logger.debug(
        f"Dark matching: found={len(matching_darks)}, exposure_matches={exposure_matches}, "
        f"needs_bias={result['needs_bias']}"
    )

    # Find matching flats
    matching_flats = find_matching_flats(light_metadata, flats)
    result["flat_count"] = len(matching_flats)
    result["has_flats"] = len(matching_flats) > 0
    result["matched_flats"] = matching_flats

    # Check bias if needed
    if result["needs_bias"]:
        matching_bias = find_matching_bias(light_metadata, bias)
        result["bias_count"] = len(matching_bias)
        result["has_bias"] = len(matching_bias) > 0
        result["matched_bias"] = matching_bias
        logger.debug(
            f"Bias needed: found={len(matching_bias)}, has_bias={result['has_bias']}"
        )

    # Determine completeness and build reason message
    missing = []
    if not result["has_darks"]:
        missing.append("darks")
    if not result["has_flats"]:
        missing.append("flats")
    if result["needs_bias"] and not result["has_bias"]:
        missing.append("bias")

    logger.debug(
        f"Completeness check: has_darks={result['has_darks']}, has_flats={result['has_flats']}, "
        f"needs_bias={result['needs_bias']}, has_bias={result.get('has_bias', 'N/A')}, "
        f"missing={missing}"
    )

    if missing:
        result["is_complete"] = False
        result["reason"] = f"Missing {', '.join(missing)}"
        result["missing"] = missing
        # Set structured skip reason code with priority: bias > flats > darks
        # This priority ensures the most specific requirement is reported first.
        # Bias is highest priority (most specific - exposure mismatch case)
        # Flats are medium priority (filter-specific)
        # Darks are lowest priority (most general)
        if result["needs_bias"] and not result["has_bias"]:
            result["skip_reason_code"] = config.SKIP_REASON_NO_BIAS
        elif not result["has_flats"]:
            result["skip_reason_code"] = config.SKIP_REASON_NO_FLATS
        elif not result["has_darks"]:
            result["skip_reason_code"] = config.SKIP_REASON_NO_DARKS
    else:
        result["is_complete"] = True
        result["missing"] = []

    return result
