"""
Calibration frame matching logic.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import logging
from pathlib import Path
from typing import Dict, List, Any, Tuple
import ap_common

from . import config

logger = logging.getLogger("ap_move_lights_to_data.matching")


def get_frames_by_type(
    directory: str,
    debug: bool = False,
) -> Dict[str, Dict[str, Any]]:
    """
    Get all frames from a directory grouped by type category.

    Groups frames into lights, darks, flats, and bias, handling MASTER types
    (e.g., "master dark", "MASTER FLAT") by checking if the type string contains
    the frame type name.

    Args:
        directory: Directory to scan for frames
        debug: Enable debug output

    Returns:
        Dict with keys 'lights', 'darks', 'flats', 'bias' containing frame metadata dicts
    """
    logger.debug(f"Scanning directory for frames: {directory}")

    # Get metadata from all files in the directory
    all_metadata = ap_common.get_metadata(
        dirs=[directory],
        patterns=config.SUPPORTED_EXTENSIONS,
        recursive=False,  # explicitly set to False
        required_properties=[config.KEYWORD_TYPE],
        profileFromPath=False,
        printStatus=debug,
    )

    # Group by type category (handles MASTER types like "master dark", "master flat")
    lights = {}
    darks = {}
    flats = {}
    bias = {}

    for filepath, metadata in all_metadata.items():
        frame_type = str(metadata.get(config.KEYWORD_TYPE, "")).lower()

        if config.TYPE_LIGHT in frame_type:
            lights[filepath] = metadata
        elif config.TYPE_DARK in frame_type:
            darks[filepath] = metadata
        elif config.TYPE_FLAT in frame_type:
            flats[filepath] = metadata
        elif config.TYPE_BIAS in frame_type:
            bias[filepath] = metadata

    logger.debug(f"Found {len(lights)} light frames")
    logger.debug(f"Found {len(darks)} dark frames")
    logger.debug(f"Found {len(flats)} flat frames")
    logger.debug(f"Found {len(bias)} bias frames")

    return {
        "lights": lights,
        "darks": darks,
        "flats": flats,
        "bias": bias,
    }


def collect_calibration_frames(
    lights_dir: str,
    source_dir: str,
    debug: bool = False,
) -> Dict[str, Dict[str, Any]]:
    """
    Collect calibration frames from lights directory and parent directories.

    Searches lights directory and all parent directories up to (but not including)
    the source directory. This supports mixed scenarios where some calibration
    frames are in the lights directory (e.g., filter-specific flats) and others
    are in parent directories (e.g., shared darks).

    Args:
        lights_dir: Directory containing light frames
        source_dir: Source root directory (stopping point)
        debug: Enable debug output

    Returns:
        Dict with keys 'darks', 'flats', 'bias' containing merged calibration frames
    """
    all_darks = {}
    all_flats = {}
    all_bias = {}

    current_dir = Path(lights_dir).resolve()
    source_path = Path(ap_common.replace_env_vars(source_dir)).resolve()
    checked_dirs = []

    while True:
        logger.debug(f"Checking for calibration frames in: {current_dir}")
        checked_dirs.append(str(current_dir))

        # Get frames from this directory (non-recursive)
        frames = get_frames_by_type(str(current_dir), debug)

        # Merge calibration frames
        all_darks.update(frames["darks"])
        all_flats.update(frames["flats"])
        all_bias.update(frames["bias"])

        # Move to parent
        parent = current_dir.parent
        if parent == current_dir:
            # Reached filesystem root
            logger.debug("Reached filesystem root")
            break

        # Stop if parent is the source directory (don't search source_dir itself)
        if parent == source_path:
            logger.debug(f"Reached source directory boundary: {source_path}")
            break

        current_dir = parent

    logger.debug(
        f"Collected {len(all_darks)} darks, {len(all_flats)} flats, "
        f"{len(all_bias)} bias from: {', '.join(checked_dirs)}"
    )

    return {
        "darks": all_darks,
        "flats": all_flats,
        "bias": all_bias,
    }


def find_matching_darks(
    light_metadata: Dict[str, Any],
    dark_frames: Dict[str, Dict[str, Any]],
) -> Tuple[List[str], bool]:
    """
    Find dark frames that match the light frame settings.

    Args:
        light_metadata: Metadata dict for a light frame
        dark_frames: Dict of dark frame metadata keyed by filepath

    Returns:
        Tuple of (list of matching dark file paths, exposure_matches)
        exposure_matches is True if any dark has same exposure as light
    """
    matching = []
    exposure_matches = False
    light_exposure = light_metadata.get(config.KEYWORD_EXPOSURESECONDS)

    for filepath, dark_meta in dark_frames.items():
        # Check all match keywords
        matches = True
        for key in config.DARK_MATCH_KEYWORDS:
            light_val = light_metadata.get(key)
            dark_val = dark_meta.get(key)
            if light_val is not None and dark_val is not None:
                if str(light_val).lower() != str(dark_val).lower():
                    matches = False
                    break

        if matches:
            matching.append(filepath)
            # Check if exposure matches
            dark_exposure = dark_meta.get(config.KEYWORD_EXPOSURESECONDS)
            if light_exposure and dark_exposure:
                try:
                    if float(light_exposure) == float(dark_exposure):
                        exposure_matches = True
                except (ValueError, TypeError):
                    pass

    logger.debug(
        f"Found {len(matching)} matching darks, exposure_matches={exposure_matches}"
    )

    return matching, exposure_matches


def find_matching_flats(
    light_metadata: Dict[str, Any],
    flat_frames: Dict[str, Dict[str, Any]],
) -> List[str]:
    """
    Find flat frames that match the light frame settings.

    Args:
        light_metadata: Metadata dict for a light frame
        flat_frames: Dict of flat frame metadata keyed by filepath

    Returns:
        List of matching flat file paths
    """
    matching = []

    for filepath, flat_meta in flat_frames.items():
        # Check all match keywords
        matches = True
        for key in config.FLAT_MATCH_KEYWORDS:
            light_val = light_metadata.get(key)
            flat_val = flat_meta.get(key)
            if light_val is not None and flat_val is not None:
                if str(light_val).lower() != str(flat_val).lower():
                    matches = False
                    break

        if matches:
            matching.append(filepath)

    logger.debug(f"Found {len(matching)} matching flats")

    return matching


def find_matching_bias(
    light_metadata: Dict[str, Any],
    bias_frames: Dict[str, Dict[str, Any]],
) -> List[str]:
    """
    Find bias frames that match the light frame settings.

    Args:
        light_metadata: Metadata dict for a light frame
        bias_frames: Dict of bias frame metadata keyed by filepath

    Returns:
        List of matching bias file paths
    """
    matching = []

    # Bias matches on same keywords as dark (minus exposure)
    for filepath, bias_meta in bias_frames.items():
        matches = True
        for key in config.DARK_MATCH_KEYWORDS:
            light_val = light_metadata.get(key)
            bias_val = bias_meta.get(key)
            if light_val is not None and bias_val is not None:
                if str(light_val).lower() != str(bias_val).lower():
                    matches = False
                    break

        if matches:
            matching.append(filepath)

    logger.debug(f"Found {len(matching)} matching bias frames")

    return matching


def check_calibration_status(
    directory: str,
    source_dir: str,
    debug: bool = False,
) -> Dict[str, Any]:
    """
    Check calibration status for a directory containing lights.

    Calibration frames are searched for in the lights directory first, then
    in parent directories up to (but not including) the source directory.
    Bias is only required if dark exposure doesn't match light exposure.

    Args:
        directory: Directory containing light frames and calibration
        source_dir: Source root directory (boundary for parent search)
        debug: Enable debug output

    Returns:
        Dict with:
            - has_lights: bool
            - has_darks: bool
            - has_flats: bool
            - has_bias: bool
            - needs_bias: bool (True if dark exposure != light exposure)
            - is_complete: bool (has all required calibration)
            - light_count, dark_count, flat_count, bias_count: int
            - light_metadata: representative light metadata
            - reason: str explaining why incomplete (if applicable)
    """
    result = {
        "has_lights": False,
        "has_darks": False,
        "has_flats": False,
        "has_bias": False,
        "needs_bias": False,
        "is_complete": False,
        "light_count": 0,
        "dark_count": 0,
        "flat_count": 0,
        "bias_count": 0,
        "light_metadata": None,
        "reason": None,
    }

    # Get light frames from the specified directory
    light_frames = get_frames_by_type(directory, debug)
    lights = light_frames["lights"]

    # Collect calibration frames from lights directory and parents
    # This supports mixed scenarios (e.g., flats in lights dir, darks in parent)
    calibration_frames = collect_calibration_frames(directory, source_dir, debug)
    darks = calibration_frames["darks"]
    flats = calibration_frames["flats"]
    bias = calibration_frames["bias"]

    result["light_count"] = len(lights)
    result["has_lights"] = len(lights) > 0

    if not lights:
        result["reason"] = "No light frames found"
        return result

    # Get representative light metadata
    light_metadata = next(iter(lights.values()))
    result["light_metadata"] = light_metadata

    # Find matching darks
    matching_darks, exposure_matches = find_matching_darks(light_metadata, darks)
    result["dark_count"] = len(matching_darks)
    result["has_darks"] = len(matching_darks) > 0

    if not matching_darks:
        result["reason"] = "No matching dark frames"
        return result

    # Determine if bias is needed
    result["needs_bias"] = not exposure_matches

    # Find matching flats
    matching_flats = find_matching_flats(light_metadata, flats)
    result["flat_count"] = len(matching_flats)
    result["has_flats"] = len(matching_flats) > 0

    if not matching_flats:
        result["reason"] = "No matching flat frames"
        return result

    # Check bias if needed
    if result["needs_bias"]:
        matching_bias = find_matching_bias(light_metadata, bias)
        result["bias_count"] = len(matching_bias)
        result["has_bias"] = len(matching_bias) > 0

        if not matching_bias:
            result["reason"] = "Dark exposure mismatch requires bias, but none found"
            return result

    # All checks passed
    result["is_complete"] = True
    return result
