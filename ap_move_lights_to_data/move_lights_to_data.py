"""
Move light frames to data directory when calibration frames are available.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import argparse
import logging
import os
import shutil
from pathlib import Path
from typing import List

import ap_common

from . import config
from .matching import check_calibration_status

logger = logging.getLogger("ap_move_lights_to_data.move_lights_to_data")


def find_light_directories(
    source_dir: str,
    debug: bool = False,
) -> List[str]:
    """
    Find directories containing light frames in the source directory.

    Uses ap-common metadata filtering to identify LIGHT frames specifically,
    not just any image files. Returns unique directories containing lights.

    Args:
        source_dir: Root directory to search (e.g., 10_Blink)
        debug: Enable debug output

    Returns:
        List of directory paths containing light frames
    """
    source_path = Path(ap_common.replace_env_vars(source_dir))

    logger.debug(f"Searching for light directories in: {source_path}")

    # Use ap-common to find LIGHT frames specifically
    light_metadata = ap_common.get_filtered_metadata(
        dirs=[str(source_path)],
        patterns=config.SUPPORTED_EXTENSIONS,
        recursive=True,
        required_properties=[config.KEYWORD_TYPE],
        filters={config.KEYWORD_TYPE: config.TYPE_LIGHT},
        profileFromPath=False,
        debug=debug,
        printStatus=debug,
    )

    # Extract unique directories from light frame paths
    light_dirs = set()
    for filepath in light_metadata.keys():
        directory = os.path.dirname(filepath)
        if directory not in light_dirs:
            light_dirs.add(directory)
            logger.debug(f"Found light frame in: {directory}")

    result = sorted(light_dirs)
    logger.info(f"Found {len(result)} directories with light frames")

    return result


def get_target_from_path(light_dir: str, source_dir: str) -> str:
    """
    Extract the target/structure path relative to source directory.

    Args:
        light_dir: Full path to light directory
        source_dir: Source root directory (e.g., 10_Blink path)

    Returns:
        Relative path structure (e.g., "M31/DATE_2024-01-15/...")
    """
    source_path = Path(ap_common.replace_env_vars(source_dir))
    light_path = Path(light_dir)

    try:
        relative = light_path.relative_to(source_path)
        return str(relative)
    except ValueError:
        # Fallback to just the directory name
        logger.warning(
            f"Could not compute relative path from {source_path} to {light_path}, "
            f"using directory name"
        )
        return light_path.name


def move_directory(
    source: str,
    dest: str,
    debug: bool = False,
    dry_run: bool = False,
) -> bool:
    """
    Move a directory and its contents to a new location.

    Args:
        source: Source directory path
        dest: Destination directory path
        debug: Enable debug output
        dry_run: If True, only print what would be done

    Returns:
        True if successful (or dry run), False otherwise
    """
    source_path = Path(source)
    dest_path = Path(dest)

    logger.debug(f"Moving: {source_path} -> {dest_path}")
    if debug or dry_run:
        print(f"  Moving: {source_path}")
        print(f"      To: {dest_path}")

    if dry_run:
        return True

    try:
        # Create parent directory if needed
        dest_path.parent.mkdir(parents=True, exist_ok=True)
        logger.debug(f"Created parent directory: {dest_path.parent}")

        # Move the directory
        shutil.move(str(source_path), str(dest_path))
        logger.info(f"Successfully moved: {source_path} -> {dest_path}")
        return True
    except Exception as e:
        logger.error(f"Error moving directory from {source_path} to {dest_path}: {e}")
        return False


def process_light_directories(
    source_dir: str,
    dest_dir: str,
    debug: bool = False,
    dry_run: bool = False,
) -> dict:
    """
    Process light directories and move those with calibration frames.

    Calibration frames (darks, flats, and bias if needed) are searched for
    in the lights directory first, then in parent directories up to (but not
    including) the source directory.

    Args:
        source_dir: Source directory containing lights (e.g., 10_Blink)
        dest_dir: Destination directory (e.g., 20_Data)
        debug: Enable debug output
        dry_run: If True, only print what would be done

    Returns:
        Dict with counts: moved, skipped (by reason), errors
    """
    results = {
        "moved": 0,
        "skipped_no_lights": 0,
        "skipped_no_darks": 0,
        "skipped_no_flats": 0,
        "skipped_no_bias": 0,
        "errors": 0,
    }

    source_path = Path(ap_common.replace_env_vars(source_dir))
    dest_path = Path(ap_common.replace_env_vars(dest_dir))

    logger.info(f"Processing light directories from {source_path} to {dest_path}")

    # Find all directories with image files
    image_dirs = find_light_directories(source_dir, debug)

    if not image_dirs:
        logger.warning(f"No image directories found in {source_path}")
        return results

    logger.info(f"Found {len(image_dirs)} directories to check")

    for image_dir in image_dirs:
        relative_path = get_target_from_path(image_dir, source_dir)
        logger.info(f"Processing: {relative_path}")

        # Check calibration status
        status = check_calibration_status(image_dir, source_dir, debug)
        logger.debug(
            f"Calibration status for {relative_path}: "
            f"lights={status['light_count']}, darks={status['dark_count']}, "
            f"flats={status['flat_count']}, bias={status['bias_count']}, "
            f"complete={status['is_complete']}"
        )

        if not status["has_lights"]:
            logger.info(f"Skipping {relative_path}: No light frames found")
            results["skipped_no_lights"] += 1
            continue

        if debug:
            print(
                f"  Lights: {status['light_count']}, "
                f"Darks: {status['dark_count']}, "
                f"Flats: {status['flat_count']}, "
                f"Bias: {status['bias_count']}"
            )
            if status["needs_bias"]:
                print("  Note: Bias required (dark exposure != light exposure)")

        if not status["is_complete"]:
            reason = status["reason"]
            logger.info(f"Skipping {relative_path}: {reason}")

            # Track specific skip reason (check bias first since reason may contain multiple keywords)
            if "bias" in reason.lower():
                results["skipped_no_bias"] += 1
            elif "flat" in reason.lower():
                results["skipped_no_flats"] += 1
            elif "dark" in reason.lower():
                results["skipped_no_darks"] += 1
            continue

        print(
            f"  Calibration complete: {status['dark_count']} darks, "
            f"{status['flat_count']} flats"
            + (f", {status['bias_count']} bias" if status["needs_bias"] else "")
        )

        # Move the directory
        dest_full = dest_path / relative_path
        success = move_directory(image_dir, str(dest_full), debug, dry_run)

        if success:
            results["moved"] += 1
            logger.info(f"Moved {relative_path} to {dest_full}")
        else:
            results["errors"] += 1
            logger.error(f"Failed to move {relative_path}")

    # Cleanup empty directories in source
    if not dry_run and results["moved"] > 0:
        logger.info(f"Cleaning up empty directories in {source_path}")
        ap_common.delete_empty_directories(str(source_path), debug=debug)

    logger.info(
        f"Processing complete: moved={results['moved']}, "
        f"skipped={results['skipped_no_lights'] + results['skipped_no_darks'] + results['skipped_no_flats'] + results['skipped_no_bias']}, "
        f"errors={results['errors']}"
    )
    return results


def main():
    """Main entry point for CLI."""
    parser = argparse.ArgumentParser(
        description="Move light frames to data directory when calibration frames exist. "
        "Calibration frames (darks, flats, bias) are searched for in the lights "
        "directory first, then in parent directories within the source tree."
    )

    parser.add_argument(
        "source_dir",
        help=f"Source directory containing lights (default name: {config.DEFAULT_BLINK_DIR})",
    )

    parser.add_argument(
        "dest_dir",
        help=f"Destination directory for lights (default name: {config.DEFAULT_DATA_DIR})",
    )

    parser.add_argument(
        "--debug",
        "-d",
        action="store_true",
        help="Enable debug output",
    )

    parser.add_argument(
        "--dry-run",
        "-n",
        action="store_true",
        help="Show what would be done without actually moving files",
    )

    args = parser.parse_args()

    # Setup logging
    config.setup_logging(debug=args.debug)

    print(f"Source directory: {args.source_dir}")
    print(f"Destination directory: {args.dest_dir}")
    print("Calibration frames searched in lights directory and parent directories")

    if args.dry_run:
        print("\n*** DRY RUN - No files will be moved ***\n")

    results = process_light_directories(
        args.source_dir,
        args.dest_dir,
        args.debug,
        args.dry_run,
    )

    # Print summary
    print("\n" + "=" * 50)
    print("Summary:")
    print(f"  Moved:              {results['moved']}")
    print(f"  Skipped (no lights):{results['skipped_no_lights']}")
    print(f"  Skipped (no darks): {results['skipped_no_darks']}")
    print(f"  Skipped (no flats): {results['skipped_no_flats']}")
    print(f"  Skipped (no bias):  {results['skipped_no_bias']}")
    print(f"  Errors:             {results['errors']}")
    print("=" * 50)


if __name__ == "__main__":
    main()
