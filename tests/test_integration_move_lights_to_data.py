"""
Integration tests for move_lights_to_data module.

These tests exercise the entire system end-to-end with minimal mocking,
creating realistic directory structures and verifying complete workflows.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import pytest
from pathlib import Path
from ap_move_light_to_data import move_lights_to_data


class TestIntegrationCompleteScenarios:
    """Integration tests for complete directory tree scenarios."""

    def test_complete_target_moves_atomically(self, tmp_path, mocker):
        """Complete TARGET with all DATEs complete moves entire TARGET."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"

        # Create TARGET/DATE1 with two complete filters sharing calibration
        target = source / "M31"
        date1 = target / "2024-01-01"
        filter_r = date1 / "FILTER_R"
        filter_b = date1 / "FILTER_B"

        # Create structure
        (filter_r / "lights").mkdir(parents=True)
        (filter_b / "lights").mkdir(parents=True)

        # Create light and calibration files
        (filter_r / "lights" / "light_r.fits").touch()
        (filter_b / "lights" / "light_b.fits").touch()
        (date1 / "dark.fits").touch()
        (date1 / "flat.fits").touch()

        # Mock only the metadata functions (not move logic)
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[str(filter_r / "lights"), str(filter_b / "lights")],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            return_value={
                "is_complete": True,
                "matched_darks": [str(date1 / "dark.fits")],
                "matched_flats": [str(date1 / "flat.fits")],
                "matched_bias": [],
                "missing": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Entire DATE1 should move as one unit
        assert result["moved"] == 1
        assert (dest / "M31" / "2024-01-01" / "dark.fits").exists()
        assert (dest / "M31" / "2024-01-01" / "flat.fits").exists()
        assert (
            dest / "M31" / "2024-01-01" / "FILTER_R" / "lights" / "light_r.fits"
        ).exists()
        assert (
            dest / "M31" / "2024-01-01" / "FILTER_B" / "lights" / "light_b.fits"
        ).exists()
        assert not date1.exists()

    def test_partial_target_moves_only_complete_dates(self, tmp_path, mocker):
        """Partial TARGET with mixed complete/incomplete DATEs moves only complete."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"

        target = source / "M31"
        date1 = target / "2024-01-01"  # Complete
        date2 = target / "2024-01-02"  # Incomplete

        # DATE1: Complete with calibration
        (date1 / "lights").mkdir(parents=True)
        (date1 / "lights" / "light1.fits").touch()
        (date1 / "dark.fits").touch()
        (date1 / "flat.fits").touch()

        # DATE2: Incomplete (no calibration)
        (date2 / "lights").mkdir(parents=True)
        (date2 / "lights" / "light2.fits").touch()

        light_dir1 = str(date1 / "lights")
        light_dir2 = str(date2 / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir1, light_dir2],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )

        def mock_check_calibration(
            light_metadata, search_dirs, allow_bias, debug, quiet, metadata_cache=None
        ):
            # Complete for DATE1, incomplete for DATE2
            if search_dirs[0] == light_dir1:
                return {
                    "is_complete": True,
                    "matched_darks": [str(date1 / "dark.fits")],
                    "matched_flats": [str(date1 / "flat.fits")],
                    "matched_bias": [],
                    "missing": [],
                }
            else:
                return {
                    "is_complete": False,
                    "matched_darks": [],
                    "matched_flats": [],
                    "matched_bias": [],
                    "missing": ["darks", "flats"],
                }

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            side_effect=mock_check_calibration,
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Only DATE1 should move
        assert result["moved"] == 1
        assert (dest / "M31" / "2024-01-01" / "lights" / "light1.fits").exists()
        assert not (dest / "M31" / "2024-01-02").exists()
        # DATE1 gone, DATE2 remains
        assert not date1.exists()
        assert date2.exists()

    def test_leaf_level_self_contained(self, tmp_path, mocker):
        """Leaf-level FILTER with its own calibration moves independently."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"

        date1 = source / "M31" / "2024-01-01"
        filter_r = date1 / "FILTER_R"

        # FILTER_R has its own calibration (self-contained)
        (filter_r / "lights").mkdir(parents=True)
        (filter_r / "lights" / "light.fits").touch()
        (filter_r / "dark.fits").touch()
        (filter_r / "flat.fits").touch()

        light_dir = str(filter_r / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            return_value={
                "is_complete": True,
                "matched_darks": [str(filter_r / "dark.fits")],
                "matched_flats": [str(filter_r / "flat.fits")],
                "matched_bias": [],
                "missing": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # FILTER_R should move independently
        assert result["moved"] == 1
        assert (
            dest / "M31" / "2024-01-01" / "FILTER_R" / "lights" / "light.fits"
        ).exists()
        assert (dest / "M31" / "2024-01-01" / "FILTER_R" / "dark.fits").exists()
        assert not filter_r.exists()

    def test_shared_calibration_blocks_complete_light(self, tmp_path, mocker):
        """Incomplete light blocks complete light when sharing calibration directory."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"

        date1 = source / "M31" / "2024-01-01"
        filter_r = date1 / "FILTER_R"  # Complete
        filter_b = date1 / "FILTER_B"  # Incomplete

        # Both share DATE1 calibration
        (filter_r / "lights").mkdir(parents=True)
        (filter_b / "lights").mkdir(parents=True)
        (filter_r / "lights" / "light_r.fits").touch()
        (filter_b / "lights" / "light_b.fits").touch()
        (date1 / "dark.fits").touch()  # Shared calibration

        light_r = str(filter_r / "lights")
        light_b = str(filter_b / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_r, light_b],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )

        def mock_check_calibration(
            light_metadata, search_dirs, allow_bias, debug, quiet, metadata_cache=None
        ):
            if search_dirs[0] == light_r:
                return {
                    "is_complete": True,
                    "matched_darks": [str(date1 / "dark.fits")],
                    "matched_flats": [],
                    "matched_bias": [],
                    "missing": [],
                }
            else:
                return {
                    "is_complete": False,
                    "matched_darks": [],
                    "matched_flats": [],
                    "matched_bias": [],
                    "missing": ["darks", "flats"],
                }

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            side_effect=mock_check_calibration,
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # DATE1 is excluded because it contains incomplete light_b
        # FILTER_R cannot move because its calibration is in excluded DATE1
        assert result["moved"] == 0
        assert not (dest / "M31").exists()
        assert date1.exists()  # Nothing moved

    def test_path_pattern_excludes_complete_tree(self, tmp_path, mocker):
        """Path pattern filters out complete tree that doesn't match."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"

        accept_dir = source / "M31" / "accept"
        reject_dir = source / "M31" / "reject"

        # Both are complete
        (accept_dir / "lights").mkdir(parents=True)
        (reject_dir / "lights").mkdir(parents=True)
        (accept_dir / "lights" / "light.fits").touch()
        (reject_dir / "lights" / "light.fits").touch()
        (accept_dir / "dark.fits").touch()
        (reject_dir / "dark.fits").touch()

        light_accept = str(accept_dir / "lights")
        light_reject = str(reject_dir / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_accept, light_reject],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            return_value={
                "is_complete": True,
                "matched_darks": [str(accept_dir / "dark.fits")],
                "matched_flats": [],
                "matched_bias": [],
                "missing": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*accept.*",  # Only accept
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Only accept should be processed and moved
        assert result["moved"] == 1
        assert (dest / "M31" / "accept").exists()
        assert not (dest / "M31" / "reject").exists()
        assert not accept_dir.exists()
        assert reject_dir.exists()  # Not processed

    def test_mixed_calibration_levels(self, tmp_path, mocker):
        """Mixed calibration levels: some self-contained, some shared."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"

        target = source / "M31"
        date1 = target / "2024-01-01"  # Self-contained
        date2 = target / "2024-01-02"  # Shares TARGET calibration

        # DATE1: Self-contained (has its own calibration)
        (date1 / "lights").mkdir(parents=True)
        (date1 / "lights" / "light1.fits").touch()
        (date1 / "dark.fits").touch()
        (date1 / "flat.fits").touch()

        # DATE2: Uses TARGET-level calibration
        (date2 / "lights").mkdir(parents=True)
        (date2 / "lights" / "light2.fits").touch()
        (target / "dark_target.fits").touch()
        (target / "flat_target.fits").touch()

        light_dir1 = str(date1 / "lights")
        light_dir2 = str(date2 / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir1, light_dir2],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )

        def mock_check_calibration(
            light_metadata, search_dirs, allow_bias, debug, quiet, metadata_cache=None
        ):
            if search_dirs[0] == light_dir1:
                return {
                    "is_complete": True,
                    "matched_darks": [str(date1 / "dark.fits")],
                    "matched_flats": [str(date1 / "flat.fits")],
                    "matched_bias": [],
                    "missing": [],
                }
            else:
                return {
                    "is_complete": True,
                    "matched_darks": [str(target / "dark_target.fits")],
                    "matched_flats": [str(target / "flat_target.fits")],
                    "matched_bias": [],
                    "missing": [],
                }

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            side_effect=mock_check_calibration,
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Both should move: DATE1 independently, entire TARGET for DATE2
        # But since both complete, TARGET should move as one unit
        assert result["moved"] == 1
        assert (dest / "M31" / "2024-01-01" / "lights" / "light1.fits").exists()
        assert (dest / "M31" / "2024-01-02" / "lights" / "light2.fits").exists()
        assert (dest / "M31" / "dark_target.fits").exists()
        assert not target.exists()
