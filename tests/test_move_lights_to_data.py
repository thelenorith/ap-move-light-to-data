"""
Tests for move_lights_to_data module.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import os
from unittest.mock import patch

from ap_move_light_to_data import move_lights_to_data


class TestFindLightDirectories:
    """Tests for find_light_directories function."""

    @patch("ap_common.get_filtered_metadata")
    def test_finds_directories_with_light_frames(self, mock_metadata, tmp_path):
        """Verify directories containing LIGHT frames are found."""
        light_dir = str(tmp_path / "10_Blink" / "M31" / "DATE_2024-01-15")
        mock_metadata.return_value = {
            os.path.join(light_dir, "light_001.fits"): {"type": "LIGHT"},
            os.path.join(light_dir, "light_002.fits"): {"type": "LIGHT"},
        }

        result = move_lights_to_data.find_light_directories(
            str(tmp_path / "10_Blink"), path_pattern=".*"
        )

        assert len(result) == 1
        assert light_dir in result

    @patch("ap_common.get_filtered_metadata")
    def test_finds_multiple_directories(self, mock_metadata, tmp_path):
        """Verify multiple directories with light frames are found."""
        dir1 = str(tmp_path / "10_Blink" / "M31")
        dir2 = str(tmp_path / "10_Blink" / "NGC7000")
        mock_metadata.return_value = {
            os.path.join(dir1, "light_001.fits"): {"type": "LIGHT"},
            os.path.join(dir2, "light_001.xisf"): {"type": "LIGHT"},
        }

        result = move_lights_to_data.find_light_directories(
            str(tmp_path / "10_Blink"), path_pattern=".*"
        )

        assert len(result) == 2
        assert dir1 in result
        assert dir2 in result

    @patch("ap_common.get_filtered_metadata")
    def test_returns_empty_for_no_light_frames(self, mock_metadata, tmp_path):
        """Verify empty list when no LIGHT frames exist."""
        mock_metadata.return_value = {}

        result = move_lights_to_data.find_light_directories(
            str(tmp_path / "10_Blink"), path_pattern=".*"
        )

        assert len(result) == 0


class TestGetTargetFromPath:
    """Tests for get_target_from_path function."""

    def test_extracts_relative_path(self, tmp_path):
        """Verify relative path extraction."""
        source = str(tmp_path / "10_Blink")
        light_dir = str(tmp_path / "10_Blink" / "M31" / "DATE_2024-01-15")

        result = move_lights_to_data.get_target_from_path(light_dir, source)

        assert result == os.path.join("M31", "DATE_2024-01-15")

    def test_handles_nested_structure(self, tmp_path):
        """Verify deeply nested structure extraction."""
        source = str(tmp_path / "10_Blink")
        light_dir = str(
            tmp_path / "10_Blink" / "M31" / "DATE_2024-01-15" / "FILTER_Ha_EXP_300"
        )

        result = move_lights_to_data.get_target_from_path(light_dir, source)

        assert "M31" in result
        assert "FILTER_Ha_EXP_300" in result


class TestMoveDirectory:
    """Tests for move_directory function."""

    def test_moves_directory_contents(self, tmp_path):
        """Verify directory is moved with contents."""
        source = tmp_path / "source" / "target"
        source.mkdir(parents=True)
        (source / "file1.fits").touch()
        (source / "file2.fits").touch()

        dest = tmp_path / "dest" / "target"

        result = move_lights_to_data.move_directory(str(source), str(dest))

        assert result is True
        assert dest.exists()
        assert (dest / "file1.fits").exists()
        assert not source.exists()

    def test_dry_run_does_not_move(self, tmp_path):
        """Verify dry run does not actually move files."""
        source = tmp_path / "source"
        source.mkdir()
        (source / "file.fits").touch()

        dest = tmp_path / "dest"

        result = move_lights_to_data.move_directory(
            str(source), str(dest), dry_run=True
        )

        assert result is True
        assert source.exists()
        assert not dest.exists()

    def test_creates_parent_directories(self, tmp_path):
        """Verify parent directories are created."""
        source = tmp_path / "source"
        source.mkdir()
        (source / "file.fits").touch()

        dest = tmp_path / "deep" / "nested" / "path" / "dest"

        result = move_lights_to_data.move_directory(str(source), str(dest))

        assert result is True
        assert dest.exists()


class TestMoveTargetFiles:
    """Tests for move_target_files function."""

    def test_moves_files_when_lights_dir_is_leaf(self, tmp_path):
        """Verify target files moved when lights directory has no subdirs."""
        # Setup: Create source/target/lights structure with a file at target level
        source = tmp_path / "source"
        target_dir = source / "M42"
        lights_dir = target_dir / "lights"
        lights_dir.mkdir(parents=True)

        # Create a light file (to make it a leaf)
        (lights_dir / "light1.fits").touch()

        # Create a target-level file that should be moved
        target_file = target_dir / "notes.txt"
        target_file.write_text("observation notes")

        dest = tmp_path / "dest"

        # Execute
        count = move_lights_to_data.move_target_files(
            str(lights_dir), str(source), str(dest)
        )

        # Verify
        assert count == 1
        assert (dest / "M42" / "notes.txt").exists()
        assert (dest / "M42" / "notes.txt").read_text() == "observation notes"
        assert not target_file.exists()

    def test_skips_when_lights_dir_has_subdirs(self, tmp_path):
        """Verify no files moved when lights directory has subdirectories."""
        # Setup
        source = tmp_path / "source"
        target_dir = source / "M42"
        lights_dir = target_dir / "lights"
        lights_dir.mkdir(parents=True)

        # Create a subdirectory in lights (not a leaf)
        (lights_dir / "subdir").mkdir()

        target_file = target_dir / "notes.txt"
        target_file.write_text("test")

        dest = tmp_path / "dest"

        # Execute
        count = move_lights_to_data.move_target_files(
            str(lights_dir), str(source), str(dest)
        )

        # Verify - nothing should move
        assert count == 0
        assert target_file.exists()


class TestMoveCalibrationFiles:
    """Tests for move_calibration_files function."""

    def test_moves_calibration_files(self, tmp_path):
        """Verify calibration files are moved with structure preserved."""
        source = tmp_path / "source"
        cal_dir = source / "calibration"
        cal_dir.mkdir(parents=True)

        dark_file = cal_dir / "dark_300s.fits"
        dark_file.write_text("dark data")

        dest = tmp_path / "dest"

        count = move_lights_to_data.move_calibration_files(
            [str(dark_file)], str(source), str(dest)
        )

        assert count == 1
        assert (dest / "calibration" / "dark_300s.fits").exists()
        assert (dest / "calibration" / "dark_300s.fits").read_text() == "dark data"
        assert not dark_file.exists()

    def test_preserves_directory_structure(self, tmp_path):
        """Verify relative paths preserved from source to dest."""
        source = tmp_path / "source"
        deep_cal = source / "a" / "b" / "c"
        deep_cal.mkdir(parents=True)

        cal_file = deep_cal / "flat.fits"
        cal_file.write_text("flat")

        dest = tmp_path / "dest"

        count = move_lights_to_data.move_calibration_files(
            [str(cal_file)], str(source), str(dest)
        )

        assert count == 1
        assert (dest / "a" / "b" / "c" / "flat.fits").exists()


class TestProcessLightDirectories:
    """Tests for process_light_directories function."""

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_skips_when_no_darks(self, mock_find, mock_status, tmp_path):
        """Verify directories are skipped when no darks exist."""
        mock_find.return_value = [str(tmp_path / "light_dir")]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": False,
            "has_flats": True,
            "has_bias": False,
            "needs_bias": False,
            "is_complete": False,
            "light_count": 10,
            "dark_count": 0,
            "flat_count": 5,
            "bias_count": 0,
            "light_metadata": {},
            "reason": "No matching dark frames",
            "skip_reason_code": "no_darks",
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        results = move_lights_to_data.process_light_directories(
            str(tmp_path / "10_Blink"),
            str(tmp_path / "20_Data"),
            path_pattern=".*",
        )

        assert results["skipped_no_darks"] == 1
        assert results["moved"] == 0

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_skips_when_no_flats(self, mock_find, mock_status, tmp_path):
        """Verify directories are skipped when no flats exist."""
        mock_find.return_value = [str(tmp_path / "light_dir")]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": True,
            "has_flats": False,
            "has_bias": False,
            "needs_bias": False,
            "is_complete": False,
            "light_count": 10,
            "dark_count": 5,
            "flat_count": 0,
            "bias_count": 0,
            "light_metadata": {},
            "reason": "No matching flat frames",
            "skip_reason_code": "no_flats",
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        results = move_lights_to_data.process_light_directories(
            str(tmp_path / "10_Blink"),
            str(tmp_path / "20_Data"),
            path_pattern=".*",
        )

        assert results["skipped_no_flats"] == 1
        assert results["moved"] == 0

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_skips_when_no_bias_needed(self, mock_find, mock_status, tmp_path):
        """Verify directories are skipped when bias needed but missing."""
        mock_find.return_value = [str(tmp_path / "light_dir")]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": True,
            "has_flats": True,
            "has_bias": False,
            "needs_bias": True,
            "is_complete": False,
            "light_count": 10,
            "dark_count": 5,
            "flat_count": 5,
            "bias_count": 0,
            "light_metadata": {},
            "reason": "Dark exposure mismatch requires bias, but none found",
            "skip_reason_code": "no_bias",
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        results = move_lights_to_data.process_light_directories(
            str(tmp_path / "10_Blink"),
            str(tmp_path / "20_Data"),
            path_pattern=".*",
        )

        assert results["skipped_no_bias"] == 1
        assert results["moved"] == 0

    @patch("ap_move_light_to_data.move_lights_to_data.ap_common")
    @patch("ap_move_light_to_data.move_lights_to_data.move_calibration_files")
    @patch("ap_move_light_to_data.move_lights_to_data.move_directory")
    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_moves_when_calibration_complete(
        self,
        mock_find,
        mock_status,
        mock_move,
        mock_move_cal,
        mock_ap_common,
        tmp_path,
    ):
        """Verify directories are moved when calibration is complete."""
        source_dir = tmp_path / "10_Blink"
        light_dir = source_dir / "M31" / "DATE_2024"
        light_dir.mkdir(parents=True)

        mock_find.return_value = [str(light_dir)]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": True,
            "has_flats": True,
            "has_bias": False,
            "needs_bias": False,
            "is_complete": True,
            "light_count": 10,
            "dark_count": 5,
            "flat_count": 5,
            "bias_count": 0,
            "light_metadata": {},
            "reason": "",
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }
        mock_move.return_value = True
        mock_move_cal.return_value = 0
        mock_ap_common.replace_env_vars.side_effect = lambda x: x

        results = move_lights_to_data.process_light_directories(
            str(source_dir),
            str(tmp_path / "20_Data"),
            path_pattern=".*",
        )

        assert results["moved"] == 1
        mock_move.assert_called_once()

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_skips_when_no_lights(self, mock_find, mock_status, tmp_path):
        """Verify directories are skipped when no light frames found."""
        mock_find.return_value = [str(tmp_path / "some_dir")]
        mock_status.return_value = {
            "has_lights": False,
            "has_darks": False,
            "has_flats": False,
            "has_bias": False,
            "needs_bias": False,
            "is_complete": False,
            "light_count": 0,
            "dark_count": 0,
            "flat_count": 0,
            "bias_count": 0,
            "light_metadata": None,
            "reason": "No light frames found",
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        results = move_lights_to_data.process_light_directories(
            str(tmp_path / "10_Blink"),
            str(tmp_path / "20_Data"),
            path_pattern=".*",
        )

        assert results["skipped_no_lights"] == 1
        assert results["moved"] == 0


class TestMoveDirectoryErrorHandling:
    """Tests for move_directory error handling."""

    def test_handles_move_error_gracefully(self, tmp_path):
        """Verify errors during move are handled gracefully."""
        source = tmp_path / "source"
        source.mkdir()
        (source / "file.fits").touch()

        dest = tmp_path / "nonexistent" / "deep" / "path" / "dest"

        with patch("shutil.move", side_effect=OSError("Permission denied")):
            result = move_lights_to_data.move_directory(str(source), str(dest))

        assert result is False
        assert source.exists()


class TestMoveTargetFilesErrorHandling:
    """Tests for move_target_files error handling."""

    def test_handles_lights_dir_not_under_source(self, tmp_path):
        """Verify graceful handling when lights_dir not under source."""
        lights_dir = tmp_path / "elsewhere" / "lights"
        lights_dir.mkdir(parents=True)
        (lights_dir / "light.fits").touch()

        source = tmp_path / "source"
        source.mkdir()

        dest = tmp_path / "dest"

        count = move_lights_to_data.move_target_files(
            str(lights_dir), str(source), str(dest)
        )

        assert count == 0

    def test_handles_lights_dir_is_source_dir(self, tmp_path):
        """Verify handling when lights directory is the source directory."""
        source = tmp_path / "source"
        source.mkdir()
        (source / "light.fits").touch()

        dest = tmp_path / "dest"

        count = move_lights_to_data.move_target_files(
            str(source), str(source), str(dest)
        )

        assert count == 0

    def test_handles_file_move_error(self, tmp_path):
        """Verify errors during file move are logged and counted."""
        source = tmp_path / "source"
        target_dir = source / "M42"
        lights_dir = target_dir / "lights"
        lights_dir.mkdir(parents=True)
        (lights_dir / "light.fits").touch()

        target_file = target_dir / "notes.txt"
        target_file.write_text("test")

        dest = tmp_path / "dest"

        with patch("ap_common.move_file", side_effect=Exception("Move failed")):
            count = move_lights_to_data.move_target_files(
                str(lights_dir), str(source), str(dest)
            )

        assert count == 0


class TestMoveCalibrationFilesErrorHandling:
    """Tests for move_calibration_files error handling."""

    def test_skips_files_not_under_source(self, tmp_path):
        """Verify files outside source tree are skipped with warning."""
        source = tmp_path / "source"
        source.mkdir()

        elsewhere = tmp_path / "elsewhere"
        elsewhere.mkdir()
        external_file = elsewhere / "dark.fits"
        external_file.write_text("dark")

        dest = tmp_path / "dest"

        count = move_lights_to_data.move_calibration_files(
            [str(external_file)], str(source), str(dest)
        )

        assert count == 0
        assert external_file.exists()

    def test_handles_move_errors_gracefully(self, tmp_path):
        """Verify errors logged and function continues."""
        source = tmp_path / "source"
        cal_dir = source / "cal"
        cal_dir.mkdir(parents=True)

        cal_file = cal_dir / "dark.fits"
        cal_file.write_text("dark")

        dest = tmp_path / "dest"

        with patch("ap_common.move_file", side_effect=OSError("Move failed")):
            count = move_lights_to_data.move_calibration_files(
                [str(cal_file)], str(source), str(dest)
            )

        assert count == 0


class TestFindLightDirectoriesEdgeCases:
    """Tests for find_light_directories edge cases."""

    @patch("ap_common.get_filtered_metadata")
    def test_handles_no_light_directories(self, mock_get_metadata, tmp_path):
        """Verify handles case when no light directories found."""
        mock_get_metadata.return_value = {}

        result = move_lights_to_data.find_light_directories(
            str(tmp_path), path_pattern=".*"
        )

        assert result == []


class TestProcessLightDirectoriesEdgeCases:
    """Tests for process_light_directories edge cases."""

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_counts_errors_on_move_failure(self, mock_find, mock_status, tmp_path):
        """Verify errors are counted when move fails."""
        light_dir = tmp_path / "lights"
        light_dir.mkdir()

        mock_find.return_value = [str(light_dir)]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": True,
            "has_flats": True,
            "has_bias": False,
            "needs_bias": False,
            "is_complete": True,
            "light_count": 10,
            "dark_count": 5,
            "flat_count": 5,
            "bias_count": 0,
            "skip_reason_code": "",
            "missing": [],
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        with patch(
            "ap_move_light_to_data.move_lights_to_data.move_directory",
            return_value=False,
        ):
            results = move_lights_to_data.process_light_directories(
                str(tmp_path),
                str(tmp_path / "dest"),
                path_pattern=".*",
            )

        assert results["errors"] == 1
        assert results["moved"] == 0

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_skips_no_bias_when_needed(self, mock_find, mock_status, tmp_path):
        """Verify skips when bias needed but missing."""
        mock_find.return_value = [str(tmp_path / "lights")]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": True,
            "has_flats": True,
            "has_bias": False,
            "needs_bias": True,
            "is_complete": False,
            "light_count": 10,
            "dark_count": 5,
            "flat_count": 5,
            "bias_count": 0,
            "skip_reason_code": "no_bias",
            "missing": ["bias"],
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        results = move_lights_to_data.process_light_directories(
            str(tmp_path),
            str(tmp_path / "dest"),
            path_pattern=".*",
        )

        assert results["skipped_no_bias"] == 1

    @patch("ap_move_light_to_data.move_lights_to_data.check_calibration_status")
    @patch("ap_move_light_to_data.move_lights_to_data.find_light_directories")
    def test_successful_move_increments_moved(self, mock_find, mock_status, tmp_path):
        """Verify successful moves are counted."""
        light_dir = tmp_path / "lights"
        light_dir.mkdir()

        mock_find.return_value = [str(light_dir)]
        mock_status.return_value = {
            "has_lights": True,
            "has_darks": True,
            "has_flats": True,
            "has_bias": False,
            "needs_bias": False,
            "is_complete": True,
            "light_count": 10,
            "dark_count": 5,
            "flat_count": 5,
            "bias_count": 0,
            "skip_reason_code": "",
            "missing": [],
            "matched_darks": [],
            "matched_flats": [],
            "matched_bias": [],
        }

        with patch(
            "ap_move_light_to_data.move_lights_to_data.move_directory",
            return_value=True,
        ):
            results = move_lights_to_data.process_light_directories(
                str(tmp_path),
                str(tmp_path / "dest"),
                path_pattern=".*",
            )

        assert results["moved"] == 1
        assert results["errors"] == 0


class TestMainCLI:
    """Tests for main() CLI function."""

    def test_exits_with_error_when_source_does_not_exist(
        self, tmp_path, monkeypatch, capsys
    ):
        """Verify exits with code 2 when source doesn't exist."""
        nonexistent = tmp_path / "nonexistent"

        monkeypatch.setattr(
            "sys.argv",
            ["ap-move-lights-to-data", str(nonexistent), str(tmp_path / "dest")],
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 2
        captured = capsys.readouterr()
        assert "ERROR: Source directory does not exist" in captured.out

    def test_exits_with_error_when_source_is_not_directory(
        self, tmp_path, monkeypatch, capsys
    ):
        """Verify exits with code 2 when source is a file."""
        source_file = tmp_path / "source.txt"
        source_file.write_text("not a directory")

        monkeypatch.setattr(
            "sys.argv",
            ["ap-move-lights-to-data", str(source_file), str(tmp_path / "dest")],
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 2
        captured = capsys.readouterr()
        assert "ERROR: Source path is not a directory" in captured.out

    def test_exits_with_error_when_dest_exists_but_not_directory(
        self, tmp_path, monkeypatch, capsys
    ):
        """Verify exits with code 2 when dest exists but is a file."""
        source = tmp_path / "source"
        source.mkdir()

        dest_file = tmp_path / "dest.txt"
        dest_file.write_text("not a directory")

        monkeypatch.setattr(
            "sys.argv", ["ap-move-lights-to-data", str(source), str(dest_file)]
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 2
        captured = capsys.readouterr()
        assert "ERROR: Destination path exists but is not a directory" in captured.out

    @patch("ap_move_light_to_data.move_lights_to_data.process_light_directories")
    def test_returns_zero_on_success(self, mock_process, tmp_path, monkeypatch, capsys):
        """Verify returns 0 when processing succeeds with no errors."""
        source = tmp_path / "source"
        source.mkdir()
        dest = tmp_path / "dest"

        mock_process.return_value = {
            "dir_count": 5,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 4,
            "moved": 5,
            "skipped_no_lights": 0,
            "skipped_no_darks": 0,
            "skipped_no_flats": 0,
            "skipped_no_bias": 0,
            "errors": 0,
        }

        monkeypatch.setattr(
            "sys.argv", ["ap-move-lights-to-data", str(source), str(dest)]
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 0

    @patch("ap_move_light_to_data.move_lights_to_data.process_light_directories")
    def test_returns_one_when_errors_occur(self, mock_process, tmp_path, monkeypatch):
        """Verify returns 1 when processing has errors."""
        source = tmp_path / "source"
        source.mkdir()
        dest = tmp_path / "dest"

        mock_process.return_value = {
            "dir_count": 5,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 4,
            "moved": 3,
            "skipped_no_lights": 0,
            "skipped_no_darks": 0,
            "skipped_no_flats": 0,
            "skipped_no_bias": 0,
            "errors": 2,
        }

        monkeypatch.setattr(
            "sys.argv", ["ap-move-lights-to-data", str(source), str(dest)]
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 1


class TestPrintSummary:
    """Tests for print_summary function.

    CRITICAL: These tests enforce the required output order and format.
    The output order has regressed multiple times and must be protected.
    """

    def test_output_order_is_bias_dark_flat(self, capsys):
        """Verify output order is ALWAYS: Biases, Darks, Flats.

        CRITICAL: This order must not change. Update this test only if
        there is an explicit business requirement to change the order.
        """
        results = {
            "dir_count": 10,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 4,
            "moved": 5,
            "skipped_no_lights": 0,
            "skipped_no_darks": 2,
            "skipped_no_flats": 3,
            "skipped_no_bias": 4,
            "biases_needed": 6,  # 6 directories need bias (4 missing, 2 present)
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=True)

        captured = capsys.readouterr()
        output_lines = captured.out.split("\n")

        # Find the calibration frame lines (skip header and directory summary)
        calibration_lines = [
            line
            for line in output_lines
            if any(frame in line for frame in ["Biases:", "Darks:", "Flats:"])
        ]

        # CRITICAL: Verify order is Biases, Darks, Flats
        assert (
            len(calibration_lines) == 3
        ), f"Expected 3 calibration lines, got {len(calibration_lines)}"
        assert (
            "Biases:" in calibration_lines[0]
        ), f"First line should be Biases, got: {calibration_lines[0]}"
        assert (
            "Darks:" in calibration_lines[1]
        ), f"Second line should be Darks, got: {calibration_lines[1]}"
        assert (
            "Flats:" in calibration_lines[2]
        ), f"Third line should be Flats, got: {calibration_lines[2]}"

    def test_bias_always_shown_even_when_zero(self, capsys):
        """Verify bias is ALWAYS shown, even when 0 of 0.

        CRITICAL: Bias must always appear in output regardless of whether
        bias frames are needed or present.
        """
        # Test case: All directories need bias and all have it
        results = {
            "dir_count": 5,
            "target_count": 1,
            "date_count": 1,
            "filter_count": 1,
            "moved": 5,
            "skipped_no_lights": 0,
            "skipped_no_darks": 0,
            "skipped_no_flats": 0,
            "skipped_no_bias": 0,  # No directories skipped for bias (all have it)
            "biases_needed": 5,  # All 5 directories need bias
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=True)

        captured = capsys.readouterr()

        # CRITICAL: Bias line must be present
        assert "Biases:" in captured.out, "Bias line must always be present in output"
        assert (
            "5 of 5" in captured.out
        ), "Should show 5 of 5 when all 5 directories need and have bias"

    def test_bias_shown_when_all_directories_missing_bias(self, capsys):
        """Verify bias is shown when all directories are missing bias (0 of N)."""
        results = {
            "dir_count": 10,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 4,
            "moved": 0,
            "skipped_no_lights": 0,
            "skipped_no_darks": 0,
            "skipped_no_flats": 0,
            "skipped_no_bias": 10,  # All directories skipped for missing bias
            "biases_needed": 10,  # All 10 directories need bias
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=True)

        captured = capsys.readouterr()

        # CRITICAL: Bias line must be present showing 0 of 10
        assert (
            "Biases:" in captured.out
        ), "Bias line must be present even when all missing"
        assert (
            "0 of 10" in captured.out
        ), "Should show 0 of 10 when all 10 directories need bias but all missing"

    def test_order_consistent_regardless_of_values(self, capsys):
        """Verify output order remains Biases, Darks, Flats regardless of which have 0."""
        # All frames missing
        results = {
            "dir_count": 10,
            "target_count": 1,
            "date_count": 1,
            "filter_count": 1,
            "moved": 0,
            "skipped_no_lights": 0,
            "skipped_no_darks": 10,
            "skipped_no_flats": 10,
            "skipped_no_bias": 10,
            "biases_needed": 10,  # All 10 directories need bias
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=True)

        captured = capsys.readouterr()
        output_lines = captured.out.split("\n")

        calibration_lines = [
            line
            for line in output_lines
            if any(frame in line for frame in ["Biases:", "Darks:", "Flats:"])
        ]

        # Order must still be Biases, Darks, Flats
        assert "Biases:" in calibration_lines[0]
        assert "Darks:" in calibration_lines[1]
        assert "Flats:" in calibration_lines[2]

    def test_bias_shows_zero_when_allow_bias_false(self, capsys):
        """Verify bias shows 0 of 0 when allow_bias=False.

        When bias checking is disabled (allow_bias=False), the output should
        show "0 of 0" to indicate bias is not being checked, rather than
        showing misleading counts that suggest bias is present.
        """
        results = {
            "dir_count": 9,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 4,
            "moved": 5,
            "skipped_no_lights": 0,
            "skipped_no_darks": 1,
            "skipped_no_flats": 1,
            "skipped_no_bias": 0,  # Never skipped for bias when allow_bias=False
            "biases_needed": 0,  # No bias counting when allow_bias=False
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=False)

        captured = capsys.readouterr()

        # When allow_bias=False, bias is not checked, so show "0 of 0"
        assert "Biases:" in captured.out, "Bias line must always be present"
        assert (
            "Biases: 0 of 0" in captured.out
        ), "Should show 0 of 0 when bias checking disabled"

    def test_bias_shows_counts_when_allow_bias_true(self, capsys):
        """Verify bias shows actual counts when allow_bias=True.

        When bias checking is enabled (allow_bias=True), the output should
        show actual counts: only directories that need bias (no exact dark match).
        """
        results = {
            "dir_count": 9,
            "target_count": 2,
            "date_count": 3,
            "filter_count": 4,
            "moved": 5,
            "skipped_no_lights": 0,
            "skipped_no_darks": 1,
            "skipped_no_flats": 1,
            "skipped_no_bias": 1,  # 1 directory skipped for missing bias
            "biases_needed": 1,  # Only 1 directory needs bias (no exact dark match)
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=True)

        captured = capsys.readouterr()

        # When allow_bias=True, biases_needed=1, skipped_no_bias=1 â†’ 0 of 1
        assert "Biases:" in captured.out, "Bias line must always be present"
        assert (
            "Biases: 0 of 1" in captured.out
        ), "Should show 0 of 1 when 1 directory needs bias but it's missing"
