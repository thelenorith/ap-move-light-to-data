"""
Tests for move_lights_to_data module.

Generated By: Claude Code (Claude Sonnet 4.5)
"""

import re
import pytest
from pathlib import Path
from ap_move_light_to_data import move_lights_to_data


class TestBuildSearchDirs:
    """Tests for build_search_dirs function."""

    def test_builds_path_from_directory_to_source(self, tmp_path):
        """Builds search path from directory up to source."""
        source = tmp_path / "source"
        level1 = source / "level1"
        level2 = level1 / "level2"
        level3 = level2 / "level3"
        level3.mkdir(parents=True)

        result = move_lights_to_data.build_search_dirs(str(level3), str(source))

        assert len(result) == 3
        assert Path(result[0]).name == "level3"
        assert Path(result[1]).name == "level2"
        assert Path(result[2]).name == "level1"

    def test_stops_at_source_boundary(self, tmp_path):
        """Does not include source directory in search path."""
        source = tmp_path / "source"
        child = source / "child"
        child.mkdir(parents=True)

        result = move_lights_to_data.build_search_dirs(str(child), str(source))

        assert len(result) == 1
        assert Path(result[0]).name == "child"

    def test_single_level_below_source(self, tmp_path):
        """Single directory below source returns one-element list."""
        source = tmp_path / "source"
        child = source / "child"
        child.mkdir(parents=True)

        result = move_lights_to_data.build_search_dirs(str(child), str(source))

        assert len(result) == 1
        assert str(Path(result[0]).resolve()) == str(child.resolve())


class TestIsTreeCompleteAndSelfContained:
    """Tests for is_group_complete_and_self_contained function."""

    def test_empty_directory_returns_not_complete(self, tmp_path):
        """Empty directory with no lights is not complete."""
        tree = tmp_path / "tree"
        tree.mkdir()

        result = move_lights_to_data.is_group_complete_and_self_contained(
            group_path=str(tree),
            source_dir=str(tmp_path),
            allow_bias=False,
            debug=False,
            quiet=True,
            metadata_cache={},
        )

        assert result["is_complete"] is False
        assert result["is_self_contained"] is False
        assert result["can_move"] is False
        assert len(result["light_directories"]) == 0

    def test_complete_self_contained_tree(self, tmp_path, mocker):
        """Tree with complete self-contained calibration can move."""
        tree = tmp_path / "tree"
        light_dir = tree / "lights"
        light_dir.mkdir(parents=True)
        cal_file1 = tree / "dark.fits"
        cal_file2 = tree / "flat.fits"
        cal_file1.touch()
        cal_file2.touch()

        # Mock finding light directories
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[str(light_dir)],
        )

        # Mock getting light frames
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )

        # Mock calibration check returning complete
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            return_value={
                "is_complete": True,
                "matched_darks": [str(cal_file1)],
                "matched_flats": [str(cal_file2)],
                "matched_bias": [],
            },
        )

        result = move_lights_to_data.is_group_complete_and_self_contained(
            str(tree), str(tmp_path), allow_bias=False, debug=False, quiet=True
        )

        assert result["is_complete"] is True
        assert result["is_self_contained"] is True
        assert result["can_move"] is True
        assert str(cal_file1) in result["calibration_files"]
        assert str(cal_file2) in result["calibration_files"]

    def test_complete_but_not_self_contained(self, tmp_path, mocker):
        """Tree with calibration in parent cannot move."""
        tree = tmp_path / "tree"
        light_dir = tree / "lights"
        light_dir.mkdir(parents=True)
        cal_file = tmp_path / "dark.fits"  # Outside tree
        cal_file.touch()

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[str(light_dir)],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            return_value={
                "is_complete": True,
                "matched_darks": [str(cal_file)],
                "matched_flats": [],
                "matched_bias": [],
            },
        )

        result = move_lights_to_data.is_group_complete_and_self_contained(
            str(tree), str(tmp_path), allow_bias=False, debug=False, quiet=True
        )

        assert result["is_complete"] is True
        assert result["is_self_contained"] is False
        assert result["can_move"] is False

    def test_incomplete_tree_tracks_missing(self, tmp_path, mocker):
        """Incomplete tree tracks which directories are missing calibration."""
        tree = tmp_path / "tree"
        light_dir = tree / "lights"
        light_dir.mkdir(parents=True)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[str(light_dir)],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={"light.fits": {"NORMALIZED_HEADER_TYPE": "Light"}},
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_calibration_for_light",
            return_value={
                "is_complete": False,
                "matched_darks": [],
                "matched_flats": [],
                "matched_bias": [],
                "missing": ["darks", "flats"],
            },
        )

        result = move_lights_to_data.is_group_complete_and_self_contained(
            str(tree), str(tmp_path), allow_bias=False, debug=False, quiet=True
        )

        assert result["is_complete"] is False
        assert len(result["incomplete_dirs"]) == 1
        assert result["incomplete_dirs"][0][0] == str(light_dir)
        assert "darks" in result["incomplete_dirs"][0][1]


class TestFilterByPattern:
    """Tests for filter_by_pattern function."""

    def test_filters_by_pattern(self):
        """Filters directories by regex pattern."""
        light_dirs = [
            "/source/M31/accept/lights",
            "/source/M31/reject/lights",
            "/source/M42/accept/lights",
        ]

        # With pattern
        result = move_lights_to_data.filter_by_pattern(
            light_dirs, path_pattern=".*accept.*"
        )
        assert len(result) == 2
        assert all("accept" in d for d in result)

        # Without pattern
        result = move_lights_to_data.filter_by_pattern(light_dirs, path_pattern=None)
        assert len(result) == 3

    def test_filter_by_pattern_matches_child_not_parent(self):
        """Pattern matches child directory even when parent doesn't match."""
        light_dirs = [
            "/source/M31/accept/lights",
            "/source/M31/reject/lights",
            "/source/M42/data/lights",
        ]

        # Pattern matches "accept" and "data" but not "M31" or "M42" directly
        result = move_lights_to_data.filter_by_pattern(
            light_dirs, path_pattern="(accept|data)"
        )
        assert len(result) == 2
        assert "/source/M31/accept/lights" in result
        assert "/source/M42/data/lights" in result
        assert "/source/M31/reject/lights" not in result

    def test_filter_by_pattern_invalid_regex(self):
        """Invalid regex pattern raises exception."""
        light_dirs = [
            "/source/M31/lights",
        ]

        # Invalid regex (unclosed bracket)
        with pytest.raises(re.error):
            move_lights_to_data.filter_by_pattern(light_dirs, path_pattern="[unclosed")

    def test_filter_by_pattern_multiple_directories_subset_match(self):
        """Pattern matches only a subset of multiple directories."""
        light_dirs = [
            "/source/M31/2024-01-01/FILTER_R/lights",
            "/source/M31/2024-01-02/FILTER_R/lights",
            "/source/M31/2024-01-03/FILTER_B/lights",
            "/source/M42/2024-01-01/FILTER_R/lights",
        ]

        # Pattern matches only M31 paths
        result = move_lights_to_data.filter_by_pattern(light_dirs, path_pattern="M31")
        assert len(result) == 3
        assert all("M31" in d for d in result)
        assert all("M42" not in d for d in result)


class TestFindCalibrationDirectories:
    """Tests for find_calibration_directories function."""

    def test_finds_calibration_directory(self, tmp_path):
        """Finds directory containing calibration files."""
        light_dir = str(tmp_path / "M31" / "DATE1" / "FILTER_R" / "lights")
        cal_dir = str(tmp_path / "M31" / "DATE1")

        status_map = {
            light_dir: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {
                    str(tmp_path / "M31" / "DATE1" / "dark.fits"),
                    str(tmp_path / "M31" / "DATE1" / "flat.fits"),
                },
            }
        }

        result = move_lights_to_data.find_calibration_directories(status_map)

        assert result[light_dir] == cal_dir

    def test_split_calibration_across_levels(self, tmp_path):
        """Calibration split across multiple levels requires leaf directory."""
        date_dir = tmp_path / "M31" / "DATE1"
        filter_dir = date_dir / "FILTER_R"
        light_dir = str(filter_dir / "lights")

        # Dark in DATE level, flat in FILTER level
        dark_file = date_dir / "dark.fits"
        flat_file = filter_dir / "flat.fits"

        status_map = {
            light_dir: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {
                    str(dark_file),
                    str(flat_file),
                },
            }
        }

        result = move_lights_to_data.find_calibration_directories(status_map)

        # Must use DATE level since it contains both darks and flats
        assert result[light_dir] == str(date_dir)

    def test_no_calibration_files(self, tmp_path):
        """Light directory with no calibration files is skipped."""
        light_dir = str(tmp_path / "M31" / "DATE1" / "FILTER_R" / "lights")

        status_map = {
            light_dir: {
                "is_complete": False,
                "missing": ["darks", "flats"],
                "calibration_files": set(),  # Empty
            }
        }

        result = move_lights_to_data.find_calibration_directories(status_map)

        # Light dir not in result because no calibration files
        assert light_dir not in result

    def test_deep_hierarchy(self, tmp_path):
        """Finds shallowest directory in deep hierarchy."""
        # Create 5-level hierarchy
        level1 = tmp_path / "TARGET"
        level2 = level1 / "DATE"
        level3 = level2 / "FILTER"
        level4 = level3 / "SUBDIR"
        level5 = level4 / "lights"
        light_dir = str(level5)

        # All calibration at level1 (TARGET)
        dark_file = level1 / "dark.fits"
        flat_file = level1 / "flat.fits"

        status_map = {
            light_dir: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {
                    str(dark_file),
                    str(flat_file),
                },
            }
        }

        result = move_lights_to_data.find_calibration_directories(status_map)

        # Should find TARGET level (shallowest containing all calibration)
        assert result[light_dir] == str(level1)


class TestOrganizeIntoMovableTrees:
    """Tests for organize_into_movable_groups function."""

    def test_excludes_parents_of_incomplete(self, tmp_path):
        """Excludes calibration dirs that are parents of incomplete lights."""
        source = tmp_path / "source"
        date1 = source / "M31" / "DATE1"
        light_complete = str(date1 / "FILTER_R" / "lights")
        light_incomplete = str(date1 / "FILTER_B" / "lights")

        status_map = {
            light_complete: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(date1 / "dark.fits")},
            },
            light_incomplete: {
                "is_complete": False,
                "missing": ["flats"],
                "calibration_files": set(),
            },
        }

        result = move_lights_to_data.organize_into_movable_groups(status_map, source)

        # DATE1 is calibration dir for complete light, but is parent of incomplete
        # So it should be excluded
        assert len(result["movable_groups"]) == 0
        assert len(result["incomplete_dirs"]) == 1

    def test_allows_leaf_calibration_dir(self, tmp_path):
        """Allows leaf directory with self-contained calibration."""
        source = tmp_path / "source"
        filter_r = source / "M31" / "DATE1" / "FILTER_R"
        light_dir = str(filter_r / "lights")

        status_map = {
            light_dir: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(filter_r / "dark.fits")},
            }
        }

        result = move_lights_to_data.organize_into_movable_groups(status_map, source)

        # FILTER_R contains all calibration and has no incomplete lights
        assert len(result["movable_groups"]) == 1
        assert result["movable_groups"][0]["path"] == filter_r

    def test_multiple_complete_lights_shared_calibration(self, tmp_path):
        """Multiple complete lights sharing calibration dir can move together."""
        source = tmp_path / "source"
        date1 = source / "M31" / "DATE1"
        filter_r = date1 / "FILTER_R"
        filter_b = date1 / "FILTER_B"
        light_r = str(filter_r / "lights")
        light_b = str(filter_b / "lights")

        # Both complete, both share DATE1 calibration
        status_map = {
            light_r: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(date1 / "dark.fits")},
            },
            light_b: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(date1 / "flat.fits")},
            },
        }

        result = move_lights_to_data.organize_into_movable_groups(status_map, source)

        # DATE1 should be movable (contains multiple complete lights)
        assert len(result["movable_groups"]) == 1
        assert result["movable_groups"][0]["path"] == date1

    def test_complete_and_incomplete_same_level(self, tmp_path):
        """Complete and incomplete at same level excludes parent calibration dir."""
        source = tmp_path / "source"
        date1 = source / "M31" / "DATE1"
        filter_r = date1 / "FILTER_R"
        filter_b = date1 / "FILTER_B"
        light_r = str(filter_r / "lights")
        light_b = str(filter_b / "lights")

        status_map = {
            light_r: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(date1 / "dark.fits")},
            },
            light_b: {
                "is_complete": False,
                "missing": ["flats"],
                "calibration_files": set(),
            },
        }

        result = move_lights_to_data.organize_into_movable_groups(status_map, source)

        # DATE1 is excluded because it contains incomplete light_b
        # FILTER_R is not movable because its calibration is in excluded DATE1
        assert len(result["movable_groups"]) == 0
        assert len(result["incomplete_dirs"]) == 1

    def test_calibration_parent_of_mixed_lights(self, tmp_path):
        """Calibration dir that is parent of mixed complete/incomplete lights excluded."""
        source = tmp_path / "source"
        date1 = source / "M31" / "DATE1"
        filter_r = date1 / "FILTER_R"
        filter_b = date1 / "FILTER_B"
        light_r = str(filter_r / "lights")
        light_b = str(filter_b / "lights")

        # DATE1 is calibration dir for complete light, but also parent of incomplete
        status_map = {
            light_r: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {
                    str(date1 / "dark.fits"),
                    str(date1 / "flat.fits"),
                },
            },
            light_b: {
                "is_complete": False,
                "missing": ["darks"],
                "calibration_files": set(),
            },
        }

        result = move_lights_to_data.organize_into_movable_groups(status_map, source)

        # DATE1 excluded from movable_groups
        assert len(result["movable_groups"]) == 0

    def test_multiple_independent_trees(self, tmp_path):
        """Multiple independent complete trees can be moved separately."""
        source = tmp_path / "source"
        m31_date1 = source / "M31" / "DATE1"
        m42_date1 = source / "M42" / "DATE1"
        light_m31 = str(m31_date1 / "lights")
        light_m42 = str(m42_date1 / "lights")

        status_map = {
            light_m31: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(m31_date1 / "dark.fits")},
            },
            light_m42: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(m42_date1 / "flat.fits")},
            },
        }

        result = move_lights_to_data.organize_into_movable_groups(status_map, source)

        # Both DATE1 directories should be movable
        assert len(result["movable_groups"]) == 2
        movable_paths = {tree["path"] for tree in result["movable_groups"]}
        assert m31_date1 in movable_paths
        assert m42_date1 in movable_paths


class TestProcessLightDirectories:
    """Tests for process_light_directories function."""

    def test_nonexistent_source_returns_error(self, tmp_path):
        """Nonexistent source directory returns with error."""
        source = tmp_path / "nonexistent"
        dest = tmp_path / "dest"

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 0
        assert result["errors"] == 0

    def test_dry_run_does_not_move_files(self, tmp_path, mocker):
        """Dry run mode does not actually move files."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree = source / "tree"
        tree.mkdir(parents=True)
        light_dir = str(tree / "lights")

        # Mock discrete steps
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {
                        "path": tree,
                        "relative_path": Path("tree"),
                    }
                ],
                "incomplete_dirs": [],
            },
        )

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=True,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 1
        assert tree.exists()  # Still exists in source
        assert not (dest / "tree").exists()  # Not in dest

    def test_dry_run_does_not_copy_files_for_real(self, tmp_path, mocker):
        """Dry run must not copy any files to destination (regression test)."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        group_dir = source / "M31" / "2024-01-01"
        group_dir.mkdir(parents=True)

        # Create actual files that would be copied
        test_file1 = group_dir / "light1.fits"
        test_file2 = group_dir / "light2.fits"
        test_file1.write_text("test data 1")
        test_file2.write_text("test data 2")

        light_dir = str(group_dir)

        # Mock only the analysis steps, not the actual file operations
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {
                        "path": group_dir,
                        "relative_path": Path("M31/2024-01-01"),
                    }
                ],
                "incomplete_dirs": [],
            },
        )

        # Run with dry_run=True
        move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=True,
            quiet=True,
            allow_bias=False,
        )

        # CRITICAL: Source files must still exist
        assert test_file1.exists(), "Dry run deleted source file!"
        assert test_file2.exists(), "Dry run deleted source file!"
        assert test_file1.read_text() == "test data 1", "Dry run modified source file!"
        assert test_file2.read_text() == "test data 2", "Dry run modified source file!"

        # CRITICAL: Destination must NOT exist or be empty
        dest_file1 = dest / "M31" / "2024-01-01" / "light1.fits"
        dest_file2 = dest / "M31" / "2024-01-01" / "light2.fits"
        assert not dest_file1.exists(), "Dry run copied files to destination!"
        assert not dest_file2.exists(), "Dry run copied files to destination!"

    def test_actually_moves_directories(self, tmp_path, mocker):
        """Actually moves directories when not dry run."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree = source / "tree"
        light_file = tree / "light.fits"
        light_file.parent.mkdir(parents=True)
        light_file.touch()
        light_dir = str(tree)

        # Mock discrete steps
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {
                        "path": tree,
                        "relative_path": Path("tree"),
                    }
                ],
                "incomplete_dirs": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 1
        assert not tree.exists()  # Gone from source
        assert (dest / "tree" / "light.fits").exists()  # In dest

    def test_tracks_skip_metrics(self, tmp_path, mocker):
        """Tracks metrics for skipped directories."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()

        light_dir1 = str(source / "dir1" / "lights")
        light_dir2 = str(source / "dir2" / "lights")
        light_dir3 = str(source / "dir3" / "lights")

        # Mock discrete steps
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir1, light_dir2, light_dir3],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir1, light_dir2, light_dir3],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir1: {
                    "is_complete": False,
                    "missing": ["darks"],
                    "calibration_files": set(),
                },
                light_dir2: {
                    "is_complete": False,
                    "missing": ["flats"],
                    "calibration_files": set(),
                },
                light_dir3: {
                    "is_complete": False,
                    "missing": ["bias"],
                    "calibration_files": set(),
                },
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [],
                "incomplete_dirs": [
                    (light_dir1, ["darks"]),
                    (light_dir2, ["flats"]),
                    (light_dir3, ["bias"]),
                ],
            },
        )

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=True,
        )

        assert result["skipped_no_darks"] == 1
        assert result["skipped_no_flats"] == 1
        assert result["skipped_no_bias"] == 1
        assert result["biases_needed"] == 1

    def test_move_multiple_trees_single_run(self, tmp_path, mocker):
        """Multiple complete trees moved in single run."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree1 = source / "tree1"
        tree2 = source / "tree2"
        tree3 = source / "tree3"

        # Create trees with files
        for tree in [tree1, tree2, tree3]:
            tree.mkdir(parents=True)
            (tree / "file.fits").touch()

        light1 = str(tree1)
        light2 = str(tree2)
        light3 = str(tree3)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light1, light2, light3],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light1, light2, light3],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light1: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
                light2: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
                light3: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {"path": tree1, "relative_path": Path("tree1")},
                    {"path": tree2, "relative_path": Path("tree2")},
                    {"path": tree3, "relative_path": Path("tree3")},
                ],
                "incomplete_dirs": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 3
        assert (dest / "tree1" / "file.fits").exists()
        assert (dest / "tree2" / "file.fits").exists()
        assert (dest / "tree3" / "file.fits").exists()
        assert not tree1.exists()
        assert not tree2.exists()
        assert not tree3.exists()

    def test_cleanup_empty_directories(self, tmp_path, mocker):
        """Empty directories cleaned up after move."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree = source / "parent" / "child" / "tree"
        tree.mkdir(parents=True)
        (tree / "file.fits").touch()

        light_dir = str(tree)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {"path": tree, "relative_path": Path("parent/child/tree")}
                ],
                "incomplete_dirs": [],
            },
        )

        mock_cleanup = mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 1
        # Verify cleanup was called with correct parameters (printStatus=False because quiet=True)
        mock_cleanup.assert_called_once_with(
            str(source), dryrun=False, printStatus=False
        )

    def test_handles_move_permission_error(self, tmp_path, mocker):
        """Permission error during copy is tracked and deletion skipped."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree1 = source / "tree1"
        tree2 = source / "tree2"
        tree1.mkdir(parents=True)
        tree2.mkdir(parents=True)
        # Add files to trees so collect_all_files_in_trees finds them
        (tree1 / "file1.fits").touch()
        (tree2 / "file2.fits").touch()

        light1 = str(tree1)
        light2 = str(tree2)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light1, light2],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light1, light2],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light1: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
                light2: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {"path": tree1, "relative_path": Path("tree1")},
                    {"path": tree2, "relative_path": Path("tree2")},
                ],
                "incomplete_dirs": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        # Mock ap_common.copy_file to raise PermissionError on first file
        mock_copy = mocker.patch("ap_common.copy_file")
        mock_copy.side_effect = [PermissionError("Access denied"), None]

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Copy failed for one file, so deletion should be skipped entirely
        assert result["moved"] == 0
        assert result["errors"] == 1

    def test_handles_disk_full_error(self, tmp_path, mocker):
        """Disk full error during copy is tracked and deletion skipped."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree = source / "tree"
        tree.mkdir(parents=True)
        # Add file so collect_all_files_in_trees finds it
        (tree / "file.fits").touch()

        light_dir = str(tree)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [{"path": tree, "relative_path": Path("tree")}],
                "incomplete_dirs": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        # Mock ap_common.copy_file to raise OSError (disk full)
        mock_copy = mocker.patch("ap_common.copy_file")
        mock_copy.side_effect = OSError("No space left on device")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 0
        assert result["errors"] == 1


class TestOutputFormatting:
    """Tests for print output formatting."""

    def test_prints_incomplete_directories(self, tmp_path, mocker, capsys):
        """Prints incomplete directories with relative paths."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()

        light_dir1 = str(source / "M31" / "DATE1" / "lights")
        light_dir2 = str(source / "M42" / "DATE1" / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir1, light_dir2],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir1, light_dir2],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir1: {
                    "is_complete": False,
                    "missing": ["darks"],
                    "calibration_files": set(),
                },
                light_dir2: {
                    "is_complete": False,
                    "missing": ["flats"],
                    "calibration_files": set(),
                },
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [],
                "incomplete_dirs": [
                    (light_dir1, ["darks"]),
                    (light_dir2, ["flats"]),
                ],
            },
        )

        move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=False,  # NOT quiet
            allow_bias=False,
        )

        captured = capsys.readouterr()
        # Should contain relative paths
        assert "M31" in captured.out
        assert "DATE1" in captured.out
        assert "M42" in captured.out
        # Should contain missing types
        assert "darks" in captured.out
        assert "flats" in captured.out

    def test_prints_multiple_missing_types(self, tmp_path, mocker, capsys):
        """Prints multiple missing calibration types for single directory."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()

        light_dir = str(source / "M31" / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": False,
                    "missing": ["darks", "flats"],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [],
                "incomplete_dirs": [
                    (light_dir, ["darks", "flats"]),
                ],
            },
        )

        move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=False,
            allow_bias=False,
        )

        captured = capsys.readouterr()
        # Should show both missing types
        assert "darks" in captured.out
        assert "flats" in captured.out
        assert "(missing:" in captured.out

    def test_quiet_suppresses_print_output(self, tmp_path, mocker, capsys):
        """Quiet mode suppresses print output."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()

        light_dir = str(source / "M31" / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": False,
                    "missing": ["darks"],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [],
                "incomplete_dirs": [
                    (light_dir, ["darks"]),
                ],
            },
        )

        move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,  # Quiet mode
            allow_bias=False,
        )

        captured = capsys.readouterr()
        # Should NOT contain incomplete directory messages
        assert "following directories are missing" not in captured.out.lower()


class TestEdgeCases:
    """Tests for edge cases in path handling."""

    def test_handles_unicode_paths(self, tmp_path, mocker):
        """Handles paths with unicode characters correctly."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        # Path with Chinese characters and emoji
        tree = source / "目标M31" / "日期2024"
        tree.mkdir(parents=True)
        (tree / "file.fits").touch()

        light_dir = str(tree)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {"path": tree, "relative_path": Path("目标M31/日期2024")}
                ],
                "incomplete_dirs": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 1
        assert (dest / "目标M31" / "日期2024" / "file.fits").exists()
        assert not tree.exists()

    def test_handles_paths_with_spaces(self, tmp_path, mocker):
        """Handles paths with spaces correctly."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        tree = source / "My Target" / "My Date" / "My Filter"
        tree.mkdir(parents=True)
        (tree / "my light.fits").touch()

        light_dir = str(tree)

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                }
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [
                    {"path": tree, "relative_path": Path("My Target/My Date/My Filter")}
                ],
                "incomplete_dirs": [],
            },
        )
        mocker.patch("ap_common.delete_empty_directories")

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        assert result["moved"] == 1
        assert (dest / "My Target" / "My Date" / "My Filter" / "my light.fits").exists()
        assert not tree.exists()

    def test_very_deep_hierarchy(self, tmp_path):
        """Handles very deep directory hierarchies (10+ levels)."""
        # Create 10-level deep hierarchy
        source = tmp_path / "source"
        current = source
        for i in range(10):
            current = current / f"level{i}"
        current.mkdir(parents=True)

        # Test find_calibration_directories with deep hierarchy
        light_dir = str(current / "lights")
        cal_file = source / "dark.fits"  # Calibration at root

        status_map = {
            light_dir: {
                "is_complete": True,
                "missing": [],
                "calibration_files": {str(cal_file)},
            }
        }

        result = move_lights_to_data.find_calibration_directories(status_map)

        # Should find source as calibration dir
        assert result[light_dir] == str(source)


class TestCriticalEdgeCases:
    """Tests for critical edge cases and error handling."""

    def test_empty_light_directory_skipped(self, tmp_path, mocker):
        """Light directory with no valid light frames is gracefully skipped."""
        source = tmp_path / "source"
        tree = source / "tree"
        light_dir = tree / "lights"
        light_dir.mkdir(parents=True)

        # Create a corrupt file that won't be recognized as a light
        (light_dir / "corrupt.fits").touch()

        # Mock find_all_light_directories to return the directory
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[str(light_dir)],
        )

        # Mock get_light_frames to return empty (no valid lights found)
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.get_light_frames",
            return_value={},  # Empty - no valid light frames
        )

        # This should complete without error
        result = move_lights_to_data.is_group_complete_and_self_contained(
            str(tree), str(source), allow_bias=False, debug=False, quiet=True
        )

        # When no valid lights are found, directory is skipped
        # Result is "complete" (nothing incomplete) but no calibration files
        assert result["is_complete"] is True  # No incomplete dirs
        assert result["can_move"] is True  # No calibration needed
        assert len(result["light_directories"]) == 1
        assert len(result["calibration_files"]) == 0  # No lights = no calibration

    def test_no_light_directories_found(self, tmp_path, mocker):
        """Empty source directory returns with appropriate warning."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()

        # Mock to return empty list (no light directories found)
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[],
        )

        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Should return empty results
        assert result["moved"] == 0
        assert result["dir_count"] == 0

    def test_pattern_matches_nothing(self, tmp_path, mocker):
        """Pattern that matches no directories returns with appropriate warning."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()

        light_dir1 = str(source / "M31" / "lights")
        light_dir2 = str(source / "M42" / "lights")

        # Mock to return light directories
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir1, light_dir2],
        )

        # Use pattern that matches nothing
        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern="NGC.*",  # Won't match M31 or M42
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Should return empty results after filtering
        assert result["moved"] == 0
        assert result["dir_count"] == 0

    def test_path_outside_source_tree(self, tmp_path, mocker):
        """Handles paths outside source tree gracefully in metrics calculation."""
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        outside = tmp_path / "outside"
        source.mkdir()
        outside.mkdir()

        # Light directory outside source tree (edge case)
        light_dir_outside = str(outside / "lights")
        light_dir_inside = str(source / "M31" / "lights")

        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[light_dir_outside, light_dir_inside],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.filter_by_pattern",
            return_value=[light_dir_outside, light_dir_inside],
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.check_light_directories",
            return_value={
                light_dir_outside: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
                light_dir_inside: {
                    "is_complete": True,
                    "missing": [],
                    "calibration_files": set(),
                },
            },
        )
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.organize_into_movable_groups",
            return_value={
                "movable_groups": [],
                "incomplete_dirs": [],
            },
        )

        # Should not crash on ValueError when calculating relative path
        result = move_lights_to_data.process_light_directories(
            str(source),
            str(dest),
            path_pattern=".*",
            debug=False,
            dry_run=False,
            quiet=True,
            allow_bias=False,
        )

        # Should complete without error
        assert result["moved"] == 0
        # target_count may be affected by ValueError being caught
        assert "target_count" in result


class TestMainValidation:
    """Tests for main() function validation logic."""

    def test_main_source_does_not_exist(self, tmp_path, mocker, capsys):
        """Main returns error code 2 when source doesn't exist."""
        source = tmp_path / "nonexistent"
        dest = tmp_path / "dest"

        # Mock sys.argv
        mocker.patch(
            "sys.argv",
            ["ap-move-light-to-data", str(source), str(dest)],
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 2
        captured = capsys.readouterr()
        assert "ERROR" in captured.out
        assert "does not exist" in captured.out

    def test_main_source_is_file_not_directory(self, tmp_path, mocker, capsys):
        """Main returns error code 2 when source is a file, not directory."""
        source = tmp_path / "file.txt"
        dest = tmp_path / "dest"
        source.touch()  # Create as file

        mocker.patch(
            "sys.argv",
            ["ap-move-light-to-data", str(source), str(dest)],
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 2
        captured = capsys.readouterr()
        assert "ERROR" in captured.out
        assert "not a directory" in captured.out

    def test_main_destination_exists_but_not_directory(self, tmp_path, mocker, capsys):
        """Main returns error code 2 when destination exists but is a file."""
        source = tmp_path / "source"
        dest = tmp_path / "dest.txt"
        source.mkdir()
        dest.touch()  # Create as file

        mocker.patch(
            "sys.argv",
            ["ap-move-light-to-data", str(source), str(dest)],
        )

        exit_code = move_lights_to_data.main()

        assert exit_code == 2
        captured = capsys.readouterr()
        assert "ERROR" in captured.out
        assert "not a directory" in captured.out


class TestPrintSummary:
    """Tests for print_summary function."""

    def test_print_summary_basic(self, capsys):
        """Prints summary with basic metrics."""
        results = {
            "dir_count": 10,
            "target_count": 2,
            "date_count": 5,
            "filter_count": 3,
            "moved": 5,
            "skipped_no_darks": 2,
            "skipped_no_flats": 1,
            "skipped_no_bias": 0,
            "biases_needed": 0,
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=False)

        captured = capsys.readouterr()
        assert "Summary" in captured.out
        assert "Directories: 10" in captured.out
        assert "2 targets" in captured.out
        assert "Darks:" in captured.out
        assert "Flats:" in captured.out

    def test_print_summary_with_bias(self, capsys):
        """Prints summary with bias metrics when allow_bias=True."""
        results = {
            "dir_count": 10,
            "target_count": 2,
            "date_count": 5,
            "filter_count": 3,
            "moved": 8,
            "skipped_no_darks": 0,
            "skipped_no_flats": 0,
            "skipped_no_bias": 2,
            "biases_needed": 3,
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=True)

        captured = capsys.readouterr()
        assert "Biases: 1 of 3" in captured.out  # 3 needed - 2 missing = 1 present
        assert "MISSING!" in captured.out

    def test_print_summary_with_errors(self, capsys):
        """Prints summary with error count."""
        results = {
            "dir_count": 10,
            "target_count": 2,
            "date_count": 5,
            "filter_count": 3,
            "moved": 5,
            "skipped_no_darks": 2,
            "skipped_no_flats": 1,
            "skipped_no_bias": 0,
            "biases_needed": 0,
            "errors": 3,
        }

        move_lights_to_data.print_summary(results, allow_bias=False)

        captured = capsys.readouterr()
        assert "Errors: 3" in captured.out

    def test_print_summary_status_indicators(self, capsys):
        """Prints correct status indicators for missing calibration."""
        results = {
            "dir_count": 10,
            "target_count": 2,
            "date_count": 5,
            "filter_count": 3,
            "moved": 5,
            "skipped_no_darks": 5,  # Half missing
            "skipped_no_flats": 10,  # All missing
            "skipped_no_bias": 0,
            "biases_needed": 0,
            "errors": 0,
        }

        move_lights_to_data.print_summary(results, allow_bias=False)

        captured = capsys.readouterr()
        assert "Darks:" in captured.out
        assert "5 of 10" in captured.out
        assert "0 of 10" in captured.out  # Flats


class TestMetadataCaching:
    """Tests for metadata caching functionality."""

    def test_get_light_frames_with_cache(self, tmp_path):
        """get_light_frames filters from cache when provided."""
        from ap_move_light_to_data.matching import get_light_frames
        from ap_move_light_to_data import config

        # Create directory with light frames
        light_dir = tmp_path / "lights"
        light_dir.mkdir()
        light1 = light_dir / "light1.fits"
        light2 = light_dir / "light2.fits"
        light1.touch()
        light2.touch()

        # Create a metadata cache
        metadata_cache = {
            str(light1): {
                config.NORMALIZED_HEADER_TYPE: "LIGHT",
                "NORMALIZED_HEADER_FILENAME": str(light1),
            },
            str(light2): {
                config.NORMALIZED_HEADER_TYPE: "LIGHT",
                "NORMALIZED_HEADER_FILENAME": str(light2),
            },
        }

        # Get lights from cache
        cached_result = get_light_frames(str(light_dir), metadata_cache=metadata_cache)

        # Should return both lights
        assert len(cached_result) == 2
        assert str(light1) in cached_result
        assert str(light2) in cached_result

    def test_find_all_light_directories_with_cache(self, tmp_path):
        """find_all_light_directories extracts dirs from cache when provided."""
        from ap_move_light_to_data.matching import find_all_light_directories
        from ap_move_light_to_data import config

        # Create nested structure
        dir1 = tmp_path / "target1" / "date1"
        dir2 = tmp_path / "target2" / "date2"
        dir1.mkdir(parents=True)
        dir2.mkdir(parents=True)
        light1 = dir1 / "light1.fits"
        light2 = dir2 / "light2.fits"
        light1.touch()
        light2.touch()

        # Create metadata cache
        metadata_cache = {
            str(light1): {
                config.NORMALIZED_HEADER_TYPE: "LIGHT",
                "NORMALIZED_HEADER_FILENAME": str(light1),
            },
            str(light2): {
                config.NORMALIZED_HEADER_TYPE: "LIGHT",
                "NORMALIZED_HEADER_FILENAME": str(light2),
            },
        }

        # Find directories from cache
        cached_result = find_all_light_directories(
            str(tmp_path), metadata_cache=metadata_cache
        )

        # Should find both directories
        assert len(cached_result) == 2
        assert str(dir1) in cached_result
        assert str(dir2) in cached_result

    def test_cache_filtering_only_includes_relevant_directory(self, tmp_path):
        """Cache filtering only includes files in the specified directory."""
        from ap_move_light_to_data.matching import get_light_frames
        from ap_move_light_to_data import config

        # Create two directories
        dir1 = tmp_path / "dir1"
        dir2 = tmp_path / "dir2"
        dir1.mkdir()
        dir2.mkdir()
        light1 = dir1 / "light1.fits"
        light2 = dir2 / "light2.fits"
        light1.touch()
        light2.touch()

        # Create cache with both
        metadata_cache = {
            str(light1): {
                config.NORMALIZED_HEADER_TYPE: "LIGHT",
                "NORMALIZED_HEADER_FILENAME": str(light1),
            },
            str(light2): {
                config.NORMALIZED_HEADER_TYPE: "LIGHT",
                "NORMALIZED_HEADER_FILENAME": str(light2),
            },
        }

        # Get lights from dir1 only
        result = get_light_frames(str(dir1), metadata_cache=metadata_cache)

        # Should only return light1
        assert len(result) == 1
        assert str(light1) in result
        assert str(light2) not in result

    def test_process_light_directories_caches_metadata_upfront(self, tmp_path, mocker):
        """process_light_directories loads metadata once upfront."""
        # Create minimal structure
        source = tmp_path / "source"
        dest = tmp_path / "dest"
        source.mkdir()
        dest.mkdir()

        # Mock get_metadata to return cache
        mock_get_metadata = mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.ap_common.get_metadata",
            return_value={},
        )

        # Mock other functions to avoid processing
        mocker.patch(
            "ap_move_light_to_data.move_lights_to_data.find_all_light_directories",
            return_value=[],
        )

        # Call process_light_directories
        move_lights_to_data.process_light_directories(
            str(source), str(dest), ".*", debug=False, dry_run=True, quiet=True
        )

        # Verify get_metadata was called exactly once
        assert mock_get_metadata.call_count == 1
        # Verify it was called with source directory
        call_args = mock_get_metadata.call_args
        assert str(source) in call_args[1]["dirs"]
